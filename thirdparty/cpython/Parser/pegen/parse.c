// @generated by pegen.py from python.gram
#include "pegen.h"

#if defined(Py_DEBUG) && defined(Py_BUILD_CORE)
extern int Py_DebugFlag;
#define D(x) if (Py_DebugFlag) x;
#else
#define D(x)
#endif

# define MAXSTACK 6000
static const int n_keyword_lists = 15;
static KeywordToken *reserved_keywords[] = {
    (KeywordToken[]) {{NULL, -1}},
    (KeywordToken[]) {{NULL, -1}},
    (KeywordToken[]) {
        {"if", 510},
        {"in", 518},
        {"as", 520},
        {"is", 527},
        {"or", 532},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"del", 503},
        {"try", 511},
        {"for", 517},
        {"def", 523},
        {"not", 526},
        {"and", 533},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"pass", 502},
        {"from", 514},
        {"elif", 515},
        {"else", 516},
        {"with", 519},
        {"True", 528},
        {"None", 530},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"raise", 501},
        {"yield", 504},
        {"break", 506},
        {"while", 512},
        {"class", 524},
        {"False", 529},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"return", 500},
        {"assert", 505},
        {"global", 508},
        {"import", 513},
        {"except", 521},
        {"lambda", 525},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"finally", 522},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"continue", 507},
        {"nonlocal", 509},
        {NULL, -1},
    },
    (KeywordToken[]) {{NULL, -1}},
    (KeywordToken[]) {{NULL, -1}},
    (KeywordToken[]) {{NULL, -1}},
    (KeywordToken[]) {{NULL, -1}},
    (KeywordToken[]) {{NULL, -1}},
    (KeywordToken[]) {
        {"__peg_parser__", 531},
        {NULL, -1},
    },
};
#define file_type 1000
#define interactive_type 1001
#define eval_type 1002
#define func_type_type 1003
#define fstring_type 1004
#define type_expressions_type 1005
#define statements_type 1006
#define statement_type 1007
#define statement_newline_type 1008
#define simple_stmt_type 1009
#define small_stmt_type 1010
#define compound_stmt_type 1011
#define assignment_type 1012
#define augassign_type 1013
#define global_stmt_type 1014
#define nonlocal_stmt_type 1015
#define yield_stmt_type 1016
#define assert_stmt_type 1017
#define del_stmt_type 1018
#define import_stmt_type 1019
#define import_name_type 1020
#define import_from_type 1021
#define import_from_targets_type 1022
#define import_from_as_names_type 1023
#define import_from_as_name_type 1024
#define dotted_as_names_type 1025
#define dotted_as_name_type 1026
#define dotted_name_type 1027  // Left-recursive
#define if_stmt_type 1028
#define elif_stmt_type 1029
#define else_block_type 1030
#define while_stmt_type 1031
#define for_stmt_type 1032
#define with_stmt_type 1033
#define with_item_type 1034
#define try_stmt_type 1035
#define except_block_type 1036
#define finally_block_type 1037
#define return_stmt_type 1038
#define raise_stmt_type 1039
#define function_def_type 1040
#define function_def_raw_type 1041
#define func_type_comment_type 1042
#define params_type 1043
#define parameters_type 1044
#define slash_no_default_type 1045
#define slash_with_default_type 1046
#define star_etc_type 1047
#define kwds_type 1048
#define param_no_default_type 1049
#define param_with_default_type 1050
#define param_maybe_default_type 1051
#define param_type 1052
#define annotation_type 1053
#define default_type 1054
#define decorators_type 1055
#define class_def_type 1056
#define class_def_raw_type 1057
#define block_type 1058
#define star_expressions_type 1059
#define star_expression_type 1060
#define star_named_expressions_type 1061
#define star_named_expression_type 1062
#define named_expression_type 1063
#define annotated_rhs_type 1064
#define expressions_type 1065
#define expression_type 1066
#define lambdef_type 1067
#define lambda_params_type 1068
#define lambda_parameters_type 1069
#define lambda_slash_no_default_type 1070
#define lambda_slash_with_default_type 1071
#define lambda_star_etc_type 1072
#define lambda_kwds_type 1073
#define lambda_param_no_default_type 1074
#define lambda_param_with_default_type 1075
#define lambda_param_maybe_default_type 1076
#define lambda_param_type 1077
#define disjunction_type 1078
#define conjunction_type 1079
#define inversion_type 1080
#define comparison_type 1081
#define compare_op_bitwise_or_pair_type 1082
#define eq_bitwise_or_type 1083
#define noteq_bitwise_or_type 1084
#define lte_bitwise_or_type 1085
#define lt_bitwise_or_type 1086
#define gte_bitwise_or_type 1087
#define gt_bitwise_or_type 1088
#define notin_bitwise_or_type 1089
#define in_bitwise_or_type 1090
#define isnot_bitwise_or_type 1091
#define is_bitwise_or_type 1092
#define bitwise_or_type 1093  // Left-recursive
#define bitwise_xor_type 1094  // Left-recursive
#define bitwise_and_type 1095  // Left-recursive
#define shift_expr_type 1096  // Left-recursive
#define sum_type 1097  // Left-recursive
#define term_type 1098  // Left-recursive
#define factor_type 1099
#define power_type 1100
#define await_primary_type 1101
#define primary_type 1102  // Left-recursive
#define slices_type 1103
#define slice_type 1104
#define atom_type 1105
#define strings_type 1106
#define list_type 1107
#define listcomp_type 1108
#define tuple_type 1109
#define group_type 1110
#define genexp_type 1111
#define set_type 1112
#define setcomp_type 1113
#define dict_type 1114
#define dictcomp_type 1115
#define double_starred_kvpairs_type 1116
#define double_starred_kvpair_type 1117
#define kvpair_type 1118
#define for_if_clauses_type 1119
#define for_if_clause_type 1120
#define yield_expr_type 1121
#define arguments_type 1122
#define args_type 1123
#define kwargs_type 1124
#define starred_expression_type 1125
#define kwarg_or_starred_type 1126
#define kwarg_or_double_starred_type 1127
#define star_targets_type 1128
#define star_targets_list_seq_type 1129
#define star_targets_tuple_seq_type 1130
#define star_target_type 1131
#define target_with_star_atom_type 1132
#define star_atom_type 1133
#define single_target_type 1134
#define single_subscript_attribute_target_type 1135
#define del_targets_type 1136
#define del_target_type 1137
#define del_t_atom_type 1138
#define t_primary_type 1139  // Left-recursive
#define t_lookahead_type 1140
#define invalid_arguments_type 1141
#define invalid_kwarg_type 1142
#define invalid_named_expression_type 1143
#define invalid_assignment_type 1144
#define invalid_ann_assign_target_type 1145
#define invalid_del_stmt_type 1146
#define invalid_block_type 1147
#define invalid_primary_type 1148  // Left-recursive
#define invalid_comprehension_type 1149
#define invalid_dict_comprehension_type 1150
#define invalid_parameters_type 1151
#define invalid_lambda_parameters_type 1152
#define invalid_star_etc_type 1153
#define invalid_lambda_star_etc_type 1154
#define invalid_double_type_comments_type 1155
#define invalid_with_item_type 1156
#define invalid_for_target_type 1157
#define invalid_group_type 1158
#define invalid_import_from_targets_type 1159
#define _loop0_1_type 1160
#define _loop0_2_type 1161
#define _loop0_4_type 1162
#define _gather_3_type 1163
#define _loop0_6_type 1164
#define _gather_5_type 1165
#define _loop0_8_type 1166
#define _gather_7_type 1167
#define _loop0_10_type 1168
#define _gather_9_type 1169
#define _loop1_11_type 1170
#define _loop0_13_type 1171
#define _gather_12_type 1172
#define _tmp_14_type 1173
#define _tmp_15_type 1174
#define _tmp_16_type 1175
#define _tmp_17_type 1176
#define _tmp_18_type 1177
#define _tmp_19_type 1178
#define _tmp_20_type 1179
#define _tmp_21_type 1180
#define _loop1_22_type 1181
#define _tmp_23_type 1182
#define _tmp_24_type 1183
#define _loop0_26_type 1184
#define _gather_25_type 1185
#define _loop0_28_type 1186
#define _gather_27_type 1187
#define _tmp_29_type 1188
#define _tmp_30_type 1189
#define _loop0_31_type 1190
#define _loop1_32_type 1191
#define _loop0_34_type 1192
#define _gather_33_type 1193
#define _tmp_35_type 1194
#define _loop0_37_type 1195
#define _gather_36_type 1196
#define _tmp_38_type 1197
#define _loop0_40_type 1198
#define _gather_39_type 1199
#define _loop0_42_type 1200
#define _gather_41_type 1201
#define _loop0_44_type 1202
#define _gather_43_type 1203
#define _loop0_46_type 1204
#define _gather_45_type 1205
#define _tmp_47_type 1206
#define _loop1_48_type 1207
#define _tmp_49_type 1208
#define _tmp_50_type 1209
#define _tmp_51_type 1210
#define _tmp_52_type 1211
#define _tmp_53_type 1212
#define _loop0_54_type 1213
#define _loop0_55_type 1214
#define _loop0_56_type 1215
#define _loop1_57_type 1216
#define _loop0_58_type 1217
#define _loop1_59_type 1218
#define _loop1_60_type 1219
#define _loop1_61_type 1220
#define _loop0_62_type 1221
#define _loop1_63_type 1222
#define _loop0_64_type 1223
#define _loop1_65_type 1224
#define _loop0_66_type 1225
#define _loop1_67_type 1226
#define _loop1_68_type 1227
#define _tmp_69_type 1228
#define _loop1_70_type 1229
#define _loop0_72_type 1230
#define _gather_71_type 1231
#define _loop1_73_type 1232
#define _loop0_74_type 1233
#define _loop0_75_type 1234
#define _loop0_76_type 1235
#define _loop1_77_type 1236
#define _loop0_78_type 1237
#define _loop1_79_type 1238
#define _loop1_80_type 1239
#define _loop1_81_type 1240
#define _loop0_82_type 1241
#define _loop1_83_type 1242
#define _loop0_84_type 1243
#define _loop1_85_type 1244
#define _loop0_86_type 1245
#define _loop1_87_type 1246
#define _loop1_88_type 1247
#define _loop1_89_type 1248
#define _loop1_90_type 1249
#define _tmp_91_type 1250
#define _loop0_93_type 1251
#define _gather_92_type 1252
#define _tmp_94_type 1253
#define _tmp_95_type 1254
#define _tmp_96_type 1255
#define _tmp_97_type 1256
#define _loop1_98_type 1257
#define _tmp_99_type 1258
#define _tmp_100_type 1259
#define _loop0_102_type 1260
#define _gather_101_type 1261
#define _loop1_103_type 1262
#define _loop0_104_type 1263
#define _loop0_105_type 1264
#define _loop0_107_type 1265
#define _gather_106_type 1266
#define _tmp_108_type 1267
#define _loop0_110_type 1268
#define _gather_109_type 1269
#define _loop0_112_type 1270
#define _gather_111_type 1271
#define _loop0_114_type 1272
#define _gather_113_type 1273
#define _loop0_116_type 1274
#define _gather_115_type 1275
#define _loop0_117_type 1276
#define _loop0_119_type 1277
#define _gather_118_type 1278
#define _loop1_120_type 1279
#define _tmp_121_type 1280
#define _loop0_123_type 1281
#define _gather_122_type 1282
#define _tmp_124_type 1283
#define _tmp_125_type 1284
#define _loop0_126_type 1285
#define _loop0_127_type 1286
#define _loop0_128_type 1287
#define _tmp_129_type 1288
#define _tmp_130_type 1289
#define _loop0_131_type 1290
#define _tmp_132_type 1291
#define _loop0_133_type 1292
#define _tmp_134_type 1293
#define _tmp_135_type 1294
#define _tmp_136_type 1295
#define _tmp_137_type 1296
#define _tmp_138_type 1297
#define _tmp_139_type 1298
#define _tmp_140_type 1299
#define _tmp_141_type 1300
#define _tmp_142_type 1301
#define _tmp_143_type 1302
#define _tmp_144_type 1303
#define _tmp_145_type 1304
#define _tmp_146_type 1305
#define _tmp_147_type 1306
#define _tmp_148_type 1307
#define _tmp_149_type 1308
#define _tmp_150_type 1309
#define _tmp_151_type 1310
#define _loop1_152_type 1311
#define _loop1_153_type 1312
#define _tmp_154_type 1313
#define _tmp_155_type 1314

static mod_ty file_rule(Parser *p);
static mod_ty interactive_rule(Parser *p);
static mod_ty eval_rule(Parser *p);
static mod_ty func_type_rule(Parser *p);
static expr_ty fstring_rule(Parser *p);
static asdl_seq* type_expressions_rule(Parser *p);
static asdl_seq* statements_rule(Parser *p);
static asdl_seq* statement_rule(Parser *p);
static asdl_seq* statement_newline_rule(Parser *p);
static asdl_seq* simple_stmt_rule(Parser *p);
static stmt_ty small_stmt_rule(Parser *p);
static stmt_ty compound_stmt_rule(Parser *p);
static stmt_ty assignment_rule(Parser *p);
static AugOperator* augassign_rule(Parser *p);
static stmt_ty global_stmt_rule(Parser *p);
static stmt_ty nonlocal_stmt_rule(Parser *p);
static stmt_ty yield_stmt_rule(Parser *p);
static stmt_ty assert_stmt_rule(Parser *p);
static stmt_ty del_stmt_rule(Parser *p);
static stmt_ty import_stmt_rule(Parser *p);
static stmt_ty import_name_rule(Parser *p);
static stmt_ty import_from_rule(Parser *p);
static asdl_seq* import_from_targets_rule(Parser *p);
static asdl_seq* import_from_as_names_rule(Parser *p);
static alias_ty import_from_as_name_rule(Parser *p);
static asdl_seq* dotted_as_names_rule(Parser *p);
static alias_ty dotted_as_name_rule(Parser *p);
static expr_ty dotted_name_rule(Parser *p);
static stmt_ty if_stmt_rule(Parser *p);
static stmt_ty elif_stmt_rule(Parser *p);
static asdl_seq* else_block_rule(Parser *p);
static stmt_ty while_stmt_rule(Parser *p);
static stmt_ty for_stmt_rule(Parser *p);
static stmt_ty with_stmt_rule(Parser *p);
static withitem_ty with_item_rule(Parser *p);
static stmt_ty try_stmt_rule(Parser *p);
static excepthandler_ty except_block_rule(Parser *p);
static asdl_seq* finally_block_rule(Parser *p);
static stmt_ty return_stmt_rule(Parser *p);
static stmt_ty raise_stmt_rule(Parser *p);
static stmt_ty function_def_rule(Parser *p);
static stmt_ty function_def_raw_rule(Parser *p);
static Token* func_type_comment_rule(Parser *p);
static arguments_ty params_rule(Parser *p);
static arguments_ty parameters_rule(Parser *p);
static asdl_seq* slash_no_default_rule(Parser *p);
static SlashWithDefault* slash_with_default_rule(Parser *p);
static StarEtc* star_etc_rule(Parser *p);
static arg_ty kwds_rule(Parser *p);
static arg_ty param_no_default_rule(Parser *p);
static NameDefaultPair* param_with_default_rule(Parser *p);
static NameDefaultPair* param_maybe_default_rule(Parser *p);
static arg_ty param_rule(Parser *p);
static expr_ty annotation_rule(Parser *p);
static expr_ty default_rule(Parser *p);
static asdl_seq* decorators_rule(Parser *p);
static stmt_ty class_def_rule(Parser *p);
static stmt_ty class_def_raw_rule(Parser *p);
static asdl_seq* block_rule(Parser *p);
static expr_ty star_expressions_rule(Parser *p);
static expr_ty star_expression_rule(Parser *p);
static asdl_seq* star_named_expressions_rule(Parser *p);
static expr_ty star_named_expression_rule(Parser *p);
static expr_ty named_expression_rule(Parser *p);
static expr_ty annotated_rhs_rule(Parser *p);
static expr_ty expressions_rule(Parser *p);
static expr_ty expression_rule(Parser *p);
static expr_ty lambdef_rule(Parser *p);
static arguments_ty lambda_params_rule(Parser *p);
static arguments_ty lambda_parameters_rule(Parser *p);
static asdl_seq* lambda_slash_no_default_rule(Parser *p);
static SlashWithDefault* lambda_slash_with_default_rule(Parser *p);
static StarEtc* lambda_star_etc_rule(Parser *p);
static arg_ty lambda_kwds_rule(Parser *p);
static arg_ty lambda_param_no_default_rule(Parser *p);
static NameDefaultPair* lambda_param_with_default_rule(Parser *p);
static NameDefaultPair* lambda_param_maybe_default_rule(Parser *p);
static arg_ty lambda_param_rule(Parser *p);
static expr_ty disjunction_rule(Parser *p);
static expr_ty conjunction_rule(Parser *p);
static expr_ty inversion_rule(Parser *p);
static expr_ty comparison_rule(Parser *p);
static CmpopExprPair* compare_op_bitwise_or_pair_rule(Parser *p);
static CmpopExprPair* eq_bitwise_or_rule(Parser *p);
static CmpopExprPair* noteq_bitwise_or_rule(Parser *p);
static CmpopExprPair* lte_bitwise_or_rule(Parser *p);
static CmpopExprPair* lt_bitwise_or_rule(Parser *p);
static CmpopExprPair* gte_bitwise_or_rule(Parser *p);
static CmpopExprPair* gt_bitwise_or_rule(Parser *p);
static CmpopExprPair* notin_bitwise_or_rule(Parser *p);
static CmpopExprPair* in_bitwise_or_rule(Parser *p);
static CmpopExprPair* isnot_bitwise_or_rule(Parser *p);
static CmpopExprPair* is_bitwise_or_rule(Parser *p);
static expr_ty bitwise_or_rule(Parser *p);
static expr_ty bitwise_xor_rule(Parser *p);
static expr_ty bitwise_and_rule(Parser *p);
static expr_ty shift_expr_rule(Parser *p);
static expr_ty sum_rule(Parser *p);
static expr_ty term_rule(Parser *p);
static expr_ty factor_rule(Parser *p);
static expr_ty power_rule(Parser *p);
static expr_ty await_primary_rule(Parser *p);
static expr_ty primary_rule(Parser *p);
static expr_ty slices_rule(Parser *p);
static expr_ty slice_rule(Parser *p);
static expr_ty atom_rule(Parser *p);
static expr_ty strings_rule(Parser *p);
static expr_ty list_rule(Parser *p);
static expr_ty listcomp_rule(Parser *p);
static expr_ty tuple_rule(Parser *p);
static expr_ty group_rule(Parser *p);
static expr_ty genexp_rule(Parser *p);
static expr_ty set_rule(Parser *p);
static expr_ty setcomp_rule(Parser *p);
static expr_ty dict_rule(Parser *p);
static expr_ty dictcomp_rule(Parser *p);
static asdl_seq* double_starred_kvpairs_rule(Parser *p);
static KeyValuePair* double_starred_kvpair_rule(Parser *p);
static KeyValuePair* kvpair_rule(Parser *p);
static asdl_seq* for_if_clauses_rule(Parser *p);
static comprehension_ty for_if_clause_rule(Parser *p);
static expr_ty yield_expr_rule(Parser *p);
static expr_ty arguments_rule(Parser *p);
static expr_ty args_rule(Parser *p);
static asdl_seq* kwargs_rule(Parser *p);
static expr_ty starred_expression_rule(Parser *p);
static KeywordOrStarred* kwarg_or_starred_rule(Parser *p);
static KeywordOrStarred* kwarg_or_double_starred_rule(Parser *p);
static expr_ty star_targets_rule(Parser *p);
static asdl_seq* star_targets_list_seq_rule(Parser *p);
static asdl_seq* star_targets_tuple_seq_rule(Parser *p);
static expr_ty star_target_rule(Parser *p);
static expr_ty target_with_star_atom_rule(Parser *p);
static expr_ty star_atom_rule(Parser *p);
static expr_ty single_target_rule(Parser *p);
static expr_ty single_subscript_attribute_target_rule(Parser *p);
static asdl_seq* del_targets_rule(Parser *p);
static expr_ty del_target_rule(Parser *p);
static expr_ty del_t_atom_rule(Parser *p);
static expr_ty t_primary_rule(Parser *p);
static void *t_lookahead_rule(Parser *p);
static void *invalid_arguments_rule(Parser *p);
static void *invalid_kwarg_rule(Parser *p);
static void *invalid_named_expression_rule(Parser *p);
static void *invalid_assignment_rule(Parser *p);
static expr_ty invalid_ann_assign_target_rule(Parser *p);
static void *invalid_del_stmt_rule(Parser *p);
static void *invalid_block_rule(Parser *p);
static void *invalid_primary_rule(Parser *p);
static void *invalid_comprehension_rule(Parser *p);
static void *invalid_dict_comprehension_rule(Parser *p);
static void *invalid_parameters_rule(Parser *p);
static void *invalid_lambda_parameters_rule(Parser *p);
static void *invalid_star_etc_rule(Parser *p);
static void *invalid_lambda_star_etc_rule(Parser *p);
static void *invalid_double_type_comments_rule(Parser *p);
static void *invalid_with_item_rule(Parser *p);
static void *invalid_for_target_rule(Parser *p);
static void *invalid_group_rule(Parser *p);
static void *invalid_import_from_targets_rule(Parser *p);
static asdl_seq *_loop0_1_rule(Parser *p);
static asdl_seq *_loop0_2_rule(Parser *p);
static asdl_seq *_loop0_4_rule(Parser *p);
static asdl_seq *_gather_3_rule(Parser *p);
static asdl_seq *_loop0_6_rule(Parser *p);
static asdl_seq *_gather_5_rule(Parser *p);
static asdl_seq *_loop0_8_rule(Parser *p);
static asdl_seq *_gather_7_rule(Parser *p);
static asdl_seq *_loop0_10_rule(Parser *p);
static asdl_seq *_gather_9_rule(Parser *p);
static asdl_seq *_loop1_11_rule(Parser *p);
static asdl_seq *_loop0_13_rule(Parser *p);
static asdl_seq *_gather_12_rule(Parser *p);
static void *_tmp_14_rule(Parser *p);
static void *_tmp_15_rule(Parser *p);
static void *_tmp_16_rule(Parser *p);
static void *_tmp_17_rule(Parser *p);
static void *_tmp_18_rule(Parser *p);
static void *_tmp_19_rule(Parser *p);
static void *_tmp_20_rule(Parser *p);
static void *_tmp_21_rule(Parser *p);
static asdl_seq *_loop1_22_rule(Parser *p);
static void *_tmp_23_rule(Parser *p);
static void *_tmp_24_rule(Parser *p);
static asdl_seq *_loop0_26_rule(Parser *p);
static asdl_seq *_gather_25_rule(Parser *p);
static asdl_seq *_loop0_28_rule(Parser *p);
static asdl_seq *_gather_27_rule(Parser *p);
static void *_tmp_29_rule(Parser *p);
static void *_tmp_30_rule(Parser *p);
static asdl_seq *_loop0_31_rule(Parser *p);
static asdl_seq *_loop1_32_rule(Parser *p);
static asdl_seq *_loop0_34_rule(Parser *p);
static asdl_seq *_gather_33_rule(Parser *p);
static void *_tmp_35_rule(Parser *p);
static asdl_seq *_loop0_37_rule(Parser *p);
static asdl_seq *_gather_36_rule(Parser *p);
static void *_tmp_38_rule(Parser *p);
static asdl_seq *_loop0_40_rule(Parser *p);
static asdl_seq *_gather_39_rule(Parser *p);
static asdl_seq *_loop0_42_rule(Parser *p);
static asdl_seq *_gather_41_rule(Parser *p);
static asdl_seq *_loop0_44_rule(Parser *p);
static asdl_seq *_gather_43_rule(Parser *p);
static asdl_seq *_loop0_46_rule(Parser *p);
static asdl_seq *_gather_45_rule(Parser *p);
static void *_tmp_47_rule(Parser *p);
static asdl_seq *_loop1_48_rule(Parser *p);
static void *_tmp_49_rule(Parser *p);
static void *_tmp_50_rule(Parser *p);
static void *_tmp_51_rule(Parser *p);
static void *_tmp_52_rule(Parser *p);
static void *_tmp_53_rule(Parser *p);
static asdl_seq *_loop0_54_rule(Parser *p);
static asdl_seq *_loop0_55_rule(Parser *p);
static asdl_seq *_loop0_56_rule(Parser *p);
static asdl_seq *_loop1_57_rule(Parser *p);
static asdl_seq *_loop0_58_rule(Parser *p);
static asdl_seq *_loop1_59_rule(Parser *p);
static asdl_seq *_loop1_60_rule(Parser *p);
static asdl_seq *_loop1_61_rule(Parser *p);
static asdl_seq *_loop0_62_rule(Parser *p);
static asdl_seq *_loop1_63_rule(Parser *p);
static asdl_seq *_loop0_64_rule(Parser *p);
static asdl_seq *_loop1_65_rule(Parser *p);
static asdl_seq *_loop0_66_rule(Parser *p);
static asdl_seq *_loop1_67_rule(Parser *p);
static asdl_seq *_loop1_68_rule(Parser *p);
static void *_tmp_69_rule(Parser *p);
static asdl_seq *_loop1_70_rule(Parser *p);
static asdl_seq *_loop0_72_rule(Parser *p);
static asdl_seq *_gather_71_rule(Parser *p);
static asdl_seq *_loop1_73_rule(Parser *p);
static asdl_seq *_loop0_74_rule(Parser *p);
static asdl_seq *_loop0_75_rule(Parser *p);
static asdl_seq *_loop0_76_rule(Parser *p);
static asdl_seq *_loop1_77_rule(Parser *p);
static asdl_seq *_loop0_78_rule(Parser *p);
static asdl_seq *_loop1_79_rule(Parser *p);
static asdl_seq *_loop1_80_rule(Parser *p);
static asdl_seq *_loop1_81_rule(Parser *p);
static asdl_seq *_loop0_82_rule(Parser *p);
static asdl_seq *_loop1_83_rule(Parser *p);
static asdl_seq *_loop0_84_rule(Parser *p);
static asdl_seq *_loop1_85_rule(Parser *p);
static asdl_seq *_loop0_86_rule(Parser *p);
static asdl_seq *_loop1_87_rule(Parser *p);
static asdl_seq *_loop1_88_rule(Parser *p);
static asdl_seq *_loop1_89_rule(Parser *p);
static asdl_seq *_loop1_90_rule(Parser *p);
static void *_tmp_91_rule(Parser *p);
static asdl_seq *_loop0_93_rule(Parser *p);
static asdl_seq *_gather_92_rule(Parser *p);
static void *_tmp_94_rule(Parser *p);
static void *_tmp_95_rule(Parser *p);
static void *_tmp_96_rule(Parser *p);
static void *_tmp_97_rule(Parser *p);
static asdl_seq *_loop1_98_rule(Parser *p);
static void *_tmp_99_rule(Parser *p);
static void *_tmp_100_rule(Parser *p);
static asdl_seq *_loop0_102_rule(Parser *p);
static asdl_seq *_gather_101_rule(Parser *p);
static asdl_seq *_loop1_103_rule(Parser *p);
static asdl_seq *_loop0_104_rule(Parser *p);
static asdl_seq *_loop0_105_rule(Parser *p);
static asdl_seq *_loop0_107_rule(Parser *p);
static asdl_seq *_gather_106_rule(Parser *p);
static void *_tmp_108_rule(Parser *p);
static asdl_seq *_loop0_110_rule(Parser *p);
static asdl_seq *_gather_109_rule(Parser *p);
static asdl_seq *_loop0_112_rule(Parser *p);
static asdl_seq *_gather_111_rule(Parser *p);
static asdl_seq *_loop0_114_rule(Parser *p);
static asdl_seq *_gather_113_rule(Parser *p);
static asdl_seq *_loop0_116_rule(Parser *p);
static asdl_seq *_gather_115_rule(Parser *p);
static asdl_seq *_loop0_117_rule(Parser *p);
static asdl_seq *_loop0_119_rule(Parser *p);
static asdl_seq *_gather_118_rule(Parser *p);
static asdl_seq *_loop1_120_rule(Parser *p);
static void *_tmp_121_rule(Parser *p);
static asdl_seq *_loop0_123_rule(Parser *p);
static asdl_seq *_gather_122_rule(Parser *p);
static void *_tmp_124_rule(Parser *p);
static void *_tmp_125_rule(Parser *p);
static asdl_seq *_loop0_126_rule(Parser *p);
static asdl_seq *_loop0_127_rule(Parser *p);
static asdl_seq *_loop0_128_rule(Parser *p);
static void *_tmp_129_rule(Parser *p);
static void *_tmp_130_rule(Parser *p);
static asdl_seq *_loop0_131_rule(Parser *p);
static void *_tmp_132_rule(Parser *p);
static asdl_seq *_loop0_133_rule(Parser *p);
static void *_tmp_134_rule(Parser *p);
static void *_tmp_135_rule(Parser *p);
static void *_tmp_136_rule(Parser *p);
static void *_tmp_137_rule(Parser *p);
static void *_tmp_138_rule(Parser *p);
static void *_tmp_139_rule(Parser *p);
static void *_tmp_140_rule(Parser *p);
static void *_tmp_141_rule(Parser *p);
static void *_tmp_142_rule(Parser *p);
static void *_tmp_143_rule(Parser *p);
static void *_tmp_144_rule(Parser *p);
static void *_tmp_145_rule(Parser *p);
static void *_tmp_146_rule(Parser *p);
static void *_tmp_147_rule(Parser *p);
static void *_tmp_148_rule(Parser *p);
static void *_tmp_149_rule(Parser *p);
static void *_tmp_150_rule(Parser *p);
static void *_tmp_151_rule(Parser *p);
static asdl_seq *_loop1_152_rule(Parser *p);
static asdl_seq *_loop1_153_rule(Parser *p);
static void *_tmp_154_rule(Parser *p);
static void *_tmp_155_rule(Parser *p);


// file: statements? $
static mod_ty
file_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    mod_ty _res = NULL;
    int _mark = p->mark;
    { // statements? $
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> file[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "statements? $"));
        void *a;
        Token * endmarker_var;
        if (
            (a = statements_rule(p), !p->error_indicator)  // statements?
            &&
            (endmarker_var = _PyPegen_expect_token(p, ENDMARKER))  // token='ENDMARKER'
        )
        {
            D(fprintf(stderr, "%*c+ file[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "statements? $"));
            _res = _PyPegen_make_module ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s file[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "statements? $"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// interactive: statement_newline
static mod_ty
interactive_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    mod_ty _res = NULL;
    int _mark = p->mark;
    { // statement_newline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> interactive[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "statement_newline"));
        asdl_seq* a;
        if (
            (a = statement_newline_rule(p))  // statement_newline
        )
        {
            D(fprintf(stderr, "%*c+ interactive[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "statement_newline"));
            _res = Interactive ( a , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s interactive[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "statement_newline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// eval: expressions NEWLINE* $
static mod_ty
eval_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    mod_ty _res = NULL;
    int _mark = p->mark;
    { // expressions NEWLINE* $
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> eval[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expressions NEWLINE* $"));
        asdl_seq * _loop0_1_var;
        expr_ty a;
        Token * endmarker_var;
        if (
            (a = expressions_rule(p))  // expressions
            &&
            (_loop0_1_var = _loop0_1_rule(p))  // NEWLINE*
            &&
            (endmarker_var = _PyPegen_expect_token(p, ENDMARKER))  // token='ENDMARKER'
        )
        {
            D(fprintf(stderr, "%*c+ eval[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expressions NEWLINE* $"));
            _res = Expression ( a , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s eval[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expressions NEWLINE* $"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// func_type: '(' type_expressions? ')' '->' expression NEWLINE* $
static mod_ty
func_type_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    mod_ty _res = NULL;
    int _mark = p->mark;
    { // '(' type_expressions? ')' '->' expression NEWLINE* $
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> func_type[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'(' type_expressions? ')' '->' expression NEWLINE* $"));
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        asdl_seq * _loop0_2_var;
        void *a;
        expr_ty b;
        Token * endmarker_var;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = type_expressions_rule(p), !p->error_indicator)  // type_expressions?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (_literal_2 = _PyPegen_expect_token(p, 51))  // token='->'
            &&
            (b = expression_rule(p))  // expression
            &&
            (_loop0_2_var = _loop0_2_rule(p))  // NEWLINE*
            &&
            (endmarker_var = _PyPegen_expect_token(p, ENDMARKER))  // token='ENDMARKER'
        )
        {
            D(fprintf(stderr, "%*c+ func_type[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' type_expressions? ')' '->' expression NEWLINE* $"));
            _res = FunctionType ( a , b , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s func_type[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'(' type_expressions? ')' '->' expression NEWLINE* $"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// fstring: star_expressions
static expr_ty
fstring_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // star_expressions
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> fstring[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_expressions"));
        expr_ty star_expressions_var;
        if (
            (star_expressions_var = star_expressions_rule(p))  // star_expressions
        )
        {
            D(fprintf(stderr, "%*c+ fstring[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_expressions"));
            _res = star_expressions_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s fstring[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_expressions"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// type_expressions:
//     | ','.expression+ ',' '*' expression ',' '**' expression
//     | ','.expression+ ',' '*' expression
//     | ','.expression+ ',' '**' expression
//     | '*' expression ',' '**' expression
//     | '*' expression
//     | '**' expression
//     | ','.expression+
static asdl_seq*
type_expressions_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.expression+ ',' '*' expression ',' '**' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.expression+ ',' '*' expression ',' '**' expression"));
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        Token * _literal_3;
        asdl_seq * a;
        expr_ty b;
        expr_ty c;
        if (
            (a = _gather_3_rule(p))  // ','.expression+
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_literal_1 = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (b = expression_rule(p))  // expression
            &&
            (_literal_2 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_literal_3 = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (c = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.expression+ ',' '*' expression ',' '**' expression"));
            _res = _PyPegen_seq_append_to_end ( p , CHECK ( _PyPegen_seq_append_to_end ( p , a , b ) ) , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.expression+ ',' '*' expression ',' '**' expression"));
    }
    { // ','.expression+ ',' '*' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.expression+ ',' '*' expression"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * a;
        expr_ty b;
        if (
            (a = _gather_5_rule(p))  // ','.expression+
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_literal_1 = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.expression+ ',' '*' expression"));
            _res = _PyPegen_seq_append_to_end ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.expression+ ',' '*' expression"));
    }
    { // ','.expression+ ',' '**' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.expression+ ',' '**' expression"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * a;
        expr_ty b;
        if (
            (a = _gather_7_rule(p))  // ','.expression+
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_literal_1 = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.expression+ ',' '**' expression"));
            _res = _PyPegen_seq_append_to_end ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.expression+ ',' '**' expression"));
    }
    { // '*' expression ',' '**' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*' expression ',' '**' expression"));
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        expr_ty a;
        expr_ty b;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = expression_rule(p))  // expression
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_literal_2 = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' expression ',' '**' expression"));
            _res = _PyPegen_seq_append_to_end ( p , CHECK ( _PyPegen_singleton_seq ( p , a ) ) , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*' expression ',' '**' expression"));
    }
    { // '*' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*' expression"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' expression"));
            _res = _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*' expression"));
    }
    { // '**' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'**' expression"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'**' expression"));
            _res = _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'**' expression"));
    }
    { // ','.expression+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.expression+"));
        asdl_seq * _gather_9_var;
        if (
            (_gather_9_var = _gather_9_rule(p))  // ','.expression+
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.expression+"));
            _res = _gather_9_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.expression+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// statements: statement+
static asdl_seq*
statements_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // statement+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statements[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "statement+"));
        asdl_seq * a;
        if (
            (a = _loop1_11_rule(p))  // statement+
        )
        {
            D(fprintf(stderr, "%*c+ statements[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "statement+"));
            _res = _PyPegen_seq_flatten ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statements[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "statement+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// statement: compound_stmt | simple_stmt
static asdl_seq*
statement_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // compound_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "compound_stmt"));
        stmt_ty a;
        if (
            (a = compound_stmt_rule(p))  // compound_stmt
        )
        {
            D(fprintf(stderr, "%*c+ statement[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "compound_stmt"));
            _res = _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "compound_stmt"));
    }
    { // simple_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "simple_stmt"));
        asdl_seq* simple_stmt_var;
        if (
            (simple_stmt_var = simple_stmt_rule(p))  // simple_stmt
        )
        {
            D(fprintf(stderr, "%*c+ statement[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "simple_stmt"));
            _res = simple_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "simple_stmt"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// statement_newline: compound_stmt NEWLINE | simple_stmt | NEWLINE | $
static asdl_seq*
statement_newline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // compound_stmt NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement_newline[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "compound_stmt NEWLINE"));
        stmt_ty a;
        Token * newline_var;
        if (
            (a = compound_stmt_rule(p))  // compound_stmt
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ statement_newline[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "compound_stmt NEWLINE"));
            _res = _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement_newline[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "compound_stmt NEWLINE"));
    }
    { // simple_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement_newline[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "simple_stmt"));
        asdl_seq* simple_stmt_var;
        if (
            (simple_stmt_var = simple_stmt_rule(p))  // simple_stmt
        )
        {
            D(fprintf(stderr, "%*c+ statement_newline[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "simple_stmt"));
            _res = simple_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement_newline[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "simple_stmt"));
    }
    { // NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement_newline[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NEWLINE"));
        Token * newline_var;
        if (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ statement_newline[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NEWLINE"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_singleton_seq ( p , CHECK ( _Py_Pass ( EXTRA ) ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement_newline[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NEWLINE"));
    }
    { // $
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement_newline[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "$"));
        Token * endmarker_var;
        if (
            (endmarker_var = _PyPegen_expect_token(p, ENDMARKER))  // token='ENDMARKER'
        )
        {
            D(fprintf(stderr, "%*c+ statement_newline[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "$"));
            _res = _PyPegen_interactive_exit ( p );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement_newline[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "$"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// simple_stmt: small_stmt !';' NEWLINE | ';'.small_stmt+ ';'? NEWLINE
static asdl_seq*
simple_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // small_stmt !';' NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "small_stmt !';' NEWLINE"));
        stmt_ty a;
        Token * newline_var;
        if (
            (a = small_stmt_rule(p))  // small_stmt
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 13)  // token=';'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "small_stmt !';' NEWLINE"));
            _res = _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "small_stmt !';' NEWLINE"));
    }
    { // ';'.small_stmt+ ';'? NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "';'.small_stmt+ ';'? NEWLINE"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_seq * a;
        Token * newline_var;
        if (
            (a = _gather_12_rule(p))  // ';'.small_stmt+
            &&
            (_opt_var = _PyPegen_expect_token(p, 13), !p->error_indicator)  // ';'?
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "';'.small_stmt+ ';'? NEWLINE"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "';'.small_stmt+ ';'? NEWLINE"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// small_stmt:
//     | assignment
//     | star_expressions
//     | &'return' return_stmt
//     | &('import' | 'from') import_stmt
//     | &'raise' raise_stmt
//     | 'pass'
//     | &'del' del_stmt
//     | &'yield' yield_stmt
//     | &'assert' assert_stmt
//     | 'break'
//     | 'continue'
//     | &'global' global_stmt
//     | &'nonlocal' nonlocal_stmt
static stmt_ty
small_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    if (_PyPegen_is_memoized(p, small_stmt_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // assignment
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> small_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "assignment"));
        stmt_ty assignment_var;
        if (
            (assignment_var = assignment_rule(p))  // assignment
        )
        {
            D(fprintf(stderr, "%*c+ small_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "assignment"));
            _res = assignment_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s small_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "assignment"));
    }
    { // star_expressions
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> small_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_expressions"));
        expr_ty e;
        if (
            (e = star_expressions_rule(p))  // star_expressions
        )
        {
            D(fprintf(stderr, "%*c+ small_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_expressions"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Expr ( e , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s small_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_expressions"));
    }
    { // &'return' return_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> small_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'return' return_stmt"));
        stmt_ty return_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 500)  // token='return'
            &&
            (return_stmt_var = return_stmt_rule(p))  // return_stmt
        )
        {
            D(fprintf(stderr, "%*c+ small_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'return' return_stmt"));
            _res = return_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s small_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'return' return_stmt"));
    }
    { // &('import' | 'from') import_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> small_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&('import' | 'from') import_stmt"));
        stmt_ty import_stmt_var;
        if (
            _PyPegen_lookahead(1, _tmp_14_rule, p)
            &&
            (import_stmt_var = import_stmt_rule(p))  // import_stmt
        )
        {
            D(fprintf(stderr, "%*c+ small_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&('import' | 'from') import_stmt"));
            _res = import_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s small_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&('import' | 'from') import_stmt"));
    }
    { // &'raise' raise_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> small_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'raise' raise_stmt"));
        stmt_ty raise_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 501)  // token='raise'
            &&
            (raise_stmt_var = raise_stmt_rule(p))  // raise_stmt
        )
        {
            D(fprintf(stderr, "%*c+ small_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'raise' raise_stmt"));
            _res = raise_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s small_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'raise' raise_stmt"));
    }
    { // 'pass'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> small_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'pass'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 502))  // token='pass'
        )
        {
            D(fprintf(stderr, "%*c+ small_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'pass'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Pass ( EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s small_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'pass'"));
    }
    { // &'del' del_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> small_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'del' del_stmt"));
        stmt_ty del_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 503)  // token='del'
            &&
            (del_stmt_var = del_stmt_rule(p))  // del_stmt
        )
        {
            D(fprintf(stderr, "%*c+ small_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'del' del_stmt"));
            _res = del_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s small_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'del' del_stmt"));
    }
    { // &'yield' yield_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> small_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'yield' yield_stmt"));
        stmt_ty yield_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 504)  // token='yield'
            &&
            (yield_stmt_var = yield_stmt_rule(p))  // yield_stmt
        )
        {
            D(fprintf(stderr, "%*c+ small_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'yield' yield_stmt"));
            _res = yield_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s small_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'yield' yield_stmt"));
    }
    { // &'assert' assert_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> small_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'assert' assert_stmt"));
        stmt_ty assert_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 505)  // token='assert'
            &&
            (assert_stmt_var = assert_stmt_rule(p))  // assert_stmt
        )
        {
            D(fprintf(stderr, "%*c+ small_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'assert' assert_stmt"));
            _res = assert_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s small_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'assert' assert_stmt"));
    }
    { // 'break'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> small_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'break'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 506))  // token='break'
        )
        {
            D(fprintf(stderr, "%*c+ small_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'break'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Break ( EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s small_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'break'"));
    }
    { // 'continue'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> small_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'continue'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 507))  // token='continue'
        )
        {
            D(fprintf(stderr, "%*c+ small_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'continue'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Continue ( EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s small_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'continue'"));
    }
    { // &'global' global_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> small_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'global' global_stmt"));
        stmt_ty global_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 508)  // token='global'
            &&
            (global_stmt_var = global_stmt_rule(p))  // global_stmt
        )
        {
            D(fprintf(stderr, "%*c+ small_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'global' global_stmt"));
            _res = global_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s small_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'global' global_stmt"));
    }
    { // &'nonlocal' nonlocal_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> small_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'nonlocal' nonlocal_stmt"));
        stmt_ty nonlocal_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 509)  // token='nonlocal'
            &&
            (nonlocal_stmt_var = nonlocal_stmt_rule(p))  // nonlocal_stmt
        )
        {
            D(fprintf(stderr, "%*c+ small_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'nonlocal' nonlocal_stmt"));
            _res = nonlocal_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s small_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'nonlocal' nonlocal_stmt"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, small_stmt_type, _res);
    p->level--;
    return _res;
}

// compound_stmt:
//     | &('def' | '@' | ASYNC) function_def
//     | &'if' if_stmt
//     | &('class' | '@') class_def
//     | &('with' | ASYNC) with_stmt
//     | &('for' | ASYNC) for_stmt
//     | &'try' try_stmt
//     | &'while' while_stmt
static stmt_ty
compound_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    { // &('def' | '@' | ASYNC) function_def
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&('def' | '@' | ASYNC) function_def"));
        stmt_ty function_def_var;
        if (
            _PyPegen_lookahead(1, _tmp_15_rule, p)
            &&
            (function_def_var = function_def_rule(p))  // function_def
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&('def' | '@' | ASYNC) function_def"));
            _res = function_def_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&('def' | '@' | ASYNC) function_def"));
    }
    { // &'if' if_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'if' if_stmt"));
        stmt_ty if_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 510)  // token='if'
            &&
            (if_stmt_var = if_stmt_rule(p))  // if_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'if' if_stmt"));
            _res = if_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'if' if_stmt"));
    }
    { // &('class' | '@') class_def
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&('class' | '@') class_def"));
        stmt_ty class_def_var;
        if (
            _PyPegen_lookahead(1, _tmp_16_rule, p)
            &&
            (class_def_var = class_def_rule(p))  // class_def
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&('class' | '@') class_def"));
            _res = class_def_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&('class' | '@') class_def"));
    }
    { // &('with' | ASYNC) with_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&('with' | ASYNC) with_stmt"));
        stmt_ty with_stmt_var;
        if (
            _PyPegen_lookahead(1, _tmp_17_rule, p)
            &&
            (with_stmt_var = with_stmt_rule(p))  // with_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&('with' | ASYNC) with_stmt"));
            _res = with_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&('with' | ASYNC) with_stmt"));
    }
    { // &('for' | ASYNC) for_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&('for' | ASYNC) for_stmt"));
        stmt_ty for_stmt_var;
        if (
            _PyPegen_lookahead(1, _tmp_18_rule, p)
            &&
            (for_stmt_var = for_stmt_rule(p))  // for_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&('for' | ASYNC) for_stmt"));
            _res = for_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&('for' | ASYNC) for_stmt"));
    }
    { // &'try' try_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'try' try_stmt"));
        stmt_ty try_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 511)  // token='try'
            &&
            (try_stmt_var = try_stmt_rule(p))  // try_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'try' try_stmt"));
            _res = try_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'try' try_stmt"));
    }
    { // &'while' while_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'while' while_stmt"));
        stmt_ty while_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 512)  // token='while'
            &&
            (while_stmt_var = while_stmt_rule(p))  // while_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'while' while_stmt"));
            _res = while_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'while' while_stmt"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// assignment:
//     | NAME ':' expression ['=' annotated_rhs]
//     | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs]
//     | ((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT?
//     | single_target augassign ~ (yield_expr | star_expressions)
//     | invalid_assignment
static stmt_ty
assignment_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME ':' expression ['=' annotated_rhs]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NAME ':' expression ['=' annotated_rhs]"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        void *c;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = expression_rule(p))  // expression
            &&
            (c = _tmp_19_rule(p), !p->error_indicator)  // ['=' annotated_rhs]
        )
        {
            D(fprintf(stderr, "%*c+ assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME ':' expression ['=' annotated_rhs]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( 6 , "Variable annotation syntax is" , _Py_AnnAssign ( CHECK ( _PyPegen_set_expr_context ( p , a , Store ) ) , b , c , 1 , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NAME ':' expression ['=' annotated_rhs]"));
    }
    { // ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs]"));
        Token * _literal;
        void *a;
        expr_ty b;
        void *c;
        if (
            (a = _tmp_20_rule(p))  // '(' single_target ')' | single_subscript_attribute_target
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = expression_rule(p))  // expression
            &&
            (c = _tmp_21_rule(p), !p->error_indicator)  // ['=' annotated_rhs]
        )
        {
            D(fprintf(stderr, "%*c+ assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( 6 , "Variable annotations syntax is" , _Py_AnnAssign ( a , b , c , 0 , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs]"));
    }
    { // ((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT?"));
        asdl_seq * a;
        void *b;
        void *tc;
        if (
            (a = _loop1_22_rule(p))  // ((star_targets '='))+
            &&
            (b = _tmp_23_rule(p))  // yield_expr | star_expressions
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 22)  // token='='
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
        )
        {
            D(fprintf(stderr, "%*c+ assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Assign ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT?"));
    }
    { // single_target augassign ~ (yield_expr | star_expressions)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "single_target augassign ~ (yield_expr | star_expressions)"));
        int _cut_var = 0;
        expr_ty a;
        AugOperator* b;
        void *c;
        if (
            (a = single_target_rule(p))  // single_target
            &&
            (b = augassign_rule(p))  // augassign
            &&
            (_cut_var = 1)
            &&
            (c = _tmp_24_rule(p))  // yield_expr | star_expressions
        )
        {
            D(fprintf(stderr, "%*c+ assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "single_target augassign ~ (yield_expr | star_expressions)"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_AugAssign ( a , b -> kind , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "single_target augassign ~ (yield_expr | star_expressions)"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    if (p->call_invalid_rules) { // invalid_assignment
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_assignment"));
        void *invalid_assignment_var;
        if (
            (invalid_assignment_var = invalid_assignment_rule(p))  // invalid_assignment
        )
        {
            D(fprintf(stderr, "%*c+ assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_assignment"));
            _res = invalid_assignment_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_assignment"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// augassign:
//     | '+='
//     | '-='
//     | '*='
//     | '@='
//     | '/='
//     | '%='
//     | '&='
//     | '|='
//     | '^='
//     | '<<='
//     | '>>='
//     | '**='
//     | '//='
static AugOperator*
augassign_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    AugOperator* _res = NULL;
    int _mark = p->mark;
    { // '+='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'+='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 36))  // token='+='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'+='"));
            _res = _PyPegen_augoperator ( p , Add );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'+='"));
    }
    { // '-='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'-='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 37))  // token='-='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'-='"));
            _res = _PyPegen_augoperator ( p , Sub );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'-='"));
    }
    { // '*='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 38))  // token='*='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*='"));
            _res = _PyPegen_augoperator ( p , Mult );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*='"));
    }
    { // '@='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'@='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 50))  // token='@='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'@='"));
            _res = CHECK_VERSION ( 5 , "The '@' operator is" , _PyPegen_augoperator ( p , MatMult ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'@='"));
    }
    { // '/='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'/='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 39))  // token='/='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'/='"));
            _res = _PyPegen_augoperator ( p , Div );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'/='"));
    }
    { // '%='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'%='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 40))  // token='%='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'%='"));
            _res = _PyPegen_augoperator ( p , Mod );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'%='"));
    }
    { // '&='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'&='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 41))  // token='&='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'&='"));
            _res = _PyPegen_augoperator ( p , BitAnd );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'&='"));
    }
    { // '|='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'|='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 42))  // token='|='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'|='"));
            _res = _PyPegen_augoperator ( p , BitOr );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'|='"));
    }
    { // '^='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'^='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 43))  // token='^='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'^='"));
            _res = _PyPegen_augoperator ( p , BitXor );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'^='"));
    }
    { // '<<='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'<<='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 44))  // token='<<='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'<<='"));
            _res = _PyPegen_augoperator ( p , LShift );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'<<='"));
    }
    { // '>>='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'>>='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 45))  // token='>>='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'>>='"));
            _res = _PyPegen_augoperator ( p , RShift );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'>>='"));
    }
    { // '**='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'**='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 46))  // token='**='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'**='"));
            _res = _PyPegen_augoperator ( p , Pow );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'**='"));
    }
    { // '//='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'//='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 48))  // token='//='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'//='"));
            _res = _PyPegen_augoperator ( p , FloorDiv );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'//='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// global_stmt: 'global' ','.NAME+
static stmt_ty
global_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'global' ','.NAME+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> global_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'global' ','.NAME+"));
        Token * _keyword;
        asdl_seq * a;
        if (
            (_keyword = _PyPegen_expect_token(p, 508))  // token='global'
            &&
            (a = _gather_25_rule(p))  // ','.NAME+
        )
        {
            D(fprintf(stderr, "%*c+ global_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'global' ','.NAME+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Global ( CHECK ( _PyPegen_map_names_to_ids ( p , a ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s global_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'global' ','.NAME+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// nonlocal_stmt: 'nonlocal' ','.NAME+
static stmt_ty
nonlocal_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'nonlocal' ','.NAME+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> nonlocal_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'nonlocal' ','.NAME+"));
        Token * _keyword;
        asdl_seq * a;
        if (
            (_keyword = _PyPegen_expect_token(p, 509))  // token='nonlocal'
            &&
            (a = _gather_27_rule(p))  // ','.NAME+
        )
        {
            D(fprintf(stderr, "%*c+ nonlocal_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'nonlocal' ','.NAME+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Nonlocal ( CHECK ( _PyPegen_map_names_to_ids ( p , a ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s nonlocal_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'nonlocal' ','.NAME+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// yield_stmt: yield_expr
static stmt_ty
yield_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // yield_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> yield_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "yield_expr"));
        expr_ty y;
        if (
            (y = yield_expr_rule(p))  // yield_expr
        )
        {
            D(fprintf(stderr, "%*c+ yield_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "yield_expr"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Expr ( y , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s yield_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "yield_expr"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// assert_stmt: 'assert' expression [',' expression]
static stmt_ty
assert_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'assert' expression [',' expression]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assert_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'assert' expression [',' expression]"));
        Token * _keyword;
        expr_ty a;
        void *b;
        if (
            (_keyword = _PyPegen_expect_token(p, 505))  // token='assert'
            &&
            (a = expression_rule(p))  // expression
            &&
            (b = _tmp_29_rule(p), !p->error_indicator)  // [',' expression]
        )
        {
            D(fprintf(stderr, "%*c+ assert_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'assert' expression [',' expression]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Assert ( a , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assert_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'assert' expression [',' expression]"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// del_stmt: 'del' del_targets &(';' | NEWLINE) | invalid_del_stmt
static stmt_ty
del_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'del' del_targets &(';' | NEWLINE)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'del' del_targets &(';' | NEWLINE)"));
        Token * _keyword;
        asdl_seq* a;
        if (
            (_keyword = _PyPegen_expect_token(p, 503))  // token='del'
            &&
            (a = del_targets_rule(p))  // del_targets
            &&
            _PyPegen_lookahead(1, _tmp_30_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ del_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'del' del_targets &(';' | NEWLINE)"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Delete ( a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'del' del_targets &(';' | NEWLINE)"));
    }
    if (p->call_invalid_rules) { // invalid_del_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_del_stmt"));
        void *invalid_del_stmt_var;
        if (
            (invalid_del_stmt_var = invalid_del_stmt_rule(p))  // invalid_del_stmt
        )
        {
            D(fprintf(stderr, "%*c+ del_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_del_stmt"));
            _res = invalid_del_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_del_stmt"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// import_stmt: import_name | import_from
static stmt_ty
import_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    { // import_name
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "import_name"));
        stmt_ty import_name_var;
        if (
            (import_name_var = import_name_rule(p))  // import_name
        )
        {
            D(fprintf(stderr, "%*c+ import_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "import_name"));
            _res = import_name_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "import_name"));
    }
    { // import_from
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "import_from"));
        stmt_ty import_from_var;
        if (
            (import_from_var = import_from_rule(p))  // import_from
        )
        {
            D(fprintf(stderr, "%*c+ import_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "import_from"));
            _res = import_from_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "import_from"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// import_name: 'import' dotted_as_names
static stmt_ty
import_name_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'import' dotted_as_names
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_name[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'import' dotted_as_names"));
        Token * _keyword;
        asdl_seq* a;
        if (
            (_keyword = _PyPegen_expect_token(p, 513))  // token='import'
            &&
            (a = dotted_as_names_rule(p))  // dotted_as_names
        )
        {
            D(fprintf(stderr, "%*c+ import_name[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'import' dotted_as_names"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Import ( a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_name[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'import' dotted_as_names"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// import_from:
//     | 'from' (('.' | '...'))* dotted_name 'import' import_from_targets
//     | 'from' (('.' | '...'))+ 'import' import_from_targets
static stmt_ty
import_from_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'from' (('.' | '...'))* dotted_name 'import' import_from_targets
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'from' (('.' | '...'))* dotted_name 'import' import_from_targets"));
        Token * _keyword;
        Token * _keyword_1;
        asdl_seq * a;
        expr_ty b;
        asdl_seq* c;
        if (
            (_keyword = _PyPegen_expect_token(p, 514))  // token='from'
            &&
            (a = _loop0_31_rule(p))  // (('.' | '...'))*
            &&
            (b = dotted_name_rule(p))  // dotted_name
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 513))  // token='import'
            &&
            (c = import_from_targets_rule(p))  // import_from_targets
        )
        {
            D(fprintf(stderr, "%*c+ import_from[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'from' (('.' | '...'))* dotted_name 'import' import_from_targets"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_ImportFrom ( b -> v . Name . id , c , _PyPegen_seq_count_dots ( a ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'from' (('.' | '...'))* dotted_name 'import' import_from_targets"));
    }
    { // 'from' (('.' | '...'))+ 'import' import_from_targets
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'from' (('.' | '...'))+ 'import' import_from_targets"));
        Token * _keyword;
        Token * _keyword_1;
        asdl_seq * a;
        asdl_seq* b;
        if (
            (_keyword = _PyPegen_expect_token(p, 514))  // token='from'
            &&
            (a = _loop1_32_rule(p))  // (('.' | '...'))+
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 513))  // token='import'
            &&
            (b = import_from_targets_rule(p))  // import_from_targets
        )
        {
            D(fprintf(stderr, "%*c+ import_from[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'from' (('.' | '...'))+ 'import' import_from_targets"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_ImportFrom ( NULL , b , _PyPegen_seq_count_dots ( a ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'from' (('.' | '...'))+ 'import' import_from_targets"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// import_from_targets:
//     | '(' import_from_as_names ','? ')'
//     | import_from_as_names !','
//     | '*'
//     | invalid_import_from_targets
static asdl_seq*
import_from_targets_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // '(' import_from_as_names ','? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from_targets[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'(' import_from_as_names ','? ')'"));
        Token * _literal;
        Token * _literal_1;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_seq* a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = import_from_as_names_rule(p))  // import_from_as_names
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ import_from_targets[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' import_from_as_names ','? ')'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from_targets[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'(' import_from_as_names ','? ')'"));
    }
    { // import_from_as_names !','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from_targets[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "import_from_as_names !','"));
        asdl_seq* import_from_as_names_var;
        if (
            (import_from_as_names_var = import_from_as_names_rule(p))  // import_from_as_names
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 12)  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ import_from_targets[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "import_from_as_names !','"));
            _res = import_from_as_names_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from_targets[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "import_from_as_names !','"));
    }
    { // '*'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from_targets[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
        )
        {
            D(fprintf(stderr, "%*c+ import_from_targets[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*'"));
            _res = _PyPegen_singleton_seq ( p , CHECK ( _PyPegen_alias_for_star ( p ) ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from_targets[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*'"));
    }
    if (p->call_invalid_rules) { // invalid_import_from_targets
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from_targets[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_import_from_targets"));
        void *invalid_import_from_targets_var;
        if (
            (invalid_import_from_targets_var = invalid_import_from_targets_rule(p))  // invalid_import_from_targets
        )
        {
            D(fprintf(stderr, "%*c+ import_from_targets[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_import_from_targets"));
            _res = invalid_import_from_targets_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from_targets[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_import_from_targets"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// import_from_as_names: ','.import_from_as_name+
static asdl_seq*
import_from_as_names_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.import_from_as_name+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from_as_names[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.import_from_as_name+"));
        asdl_seq * a;
        if (
            (a = _gather_33_rule(p))  // ','.import_from_as_name+
        )
        {
            D(fprintf(stderr, "%*c+ import_from_as_names[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.import_from_as_name+"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from_as_names[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.import_from_as_name+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// import_from_as_name: NAME ['as' NAME]
static alias_ty
import_from_as_name_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    alias_ty _res = NULL;
    int _mark = p->mark;
    { // NAME ['as' NAME]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from_as_name[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NAME ['as' NAME]"));
        expr_ty a;
        void *b;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (b = _tmp_35_rule(p), !p->error_indicator)  // ['as' NAME]
        )
        {
            D(fprintf(stderr, "%*c+ import_from_as_name[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME ['as' NAME]"));
            _res = _Py_alias ( a -> v . Name . id , ( b ) ? ( ( expr_ty ) b ) -> v . Name . id : NULL , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from_as_name[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NAME ['as' NAME]"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// dotted_as_names: ','.dotted_as_name+
static asdl_seq*
dotted_as_names_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.dotted_as_name+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dotted_as_names[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.dotted_as_name+"));
        asdl_seq * a;
        if (
            (a = _gather_36_rule(p))  // ','.dotted_as_name+
        )
        {
            D(fprintf(stderr, "%*c+ dotted_as_names[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.dotted_as_name+"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dotted_as_names[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.dotted_as_name+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// dotted_as_name: dotted_name ['as' NAME]
static alias_ty
dotted_as_name_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    alias_ty _res = NULL;
    int _mark = p->mark;
    { // dotted_name ['as' NAME]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dotted_as_name[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "dotted_name ['as' NAME]"));
        expr_ty a;
        void *b;
        if (
            (a = dotted_name_rule(p))  // dotted_name
            &&
            (b = _tmp_38_rule(p), !p->error_indicator)  // ['as' NAME]
        )
        {
            D(fprintf(stderr, "%*c+ dotted_as_name[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "dotted_name ['as' NAME]"));
            _res = _Py_alias ( a -> v . Name . id , ( b ) ? ( ( expr_ty ) b ) -> v . Name . id : NULL , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dotted_as_name[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "dotted_name ['as' NAME]"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// dotted_name: dotted_name '.' NAME | NAME
static expr_ty dotted_name_raw(Parser *);
static expr_ty
dotted_name_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, dotted_name_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_0 = _PyPegen_update_memo(p, _mark, dotted_name_type, _res);
        if (tmpvar_0) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = dotted_name_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
dotted_name_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // dotted_name '.' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dotted_name[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "dotted_name '.' NAME"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = dotted_name_rule(p))  // dotted_name
            &&
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
            &&
            (b = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ dotted_name[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "dotted_name '.' NAME"));
            _res = _PyPegen_join_names_with_dot ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dotted_name[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "dotted_name '.' NAME"));
    }
    { // NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dotted_name[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NAME"));
        expr_ty name_var;
        if (
            (name_var = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ dotted_name[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME"));
            _res = name_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dotted_name[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// if_stmt:
//     | 'if' named_expression ':' block elif_stmt
//     | 'if' named_expression ':' block else_block?
static stmt_ty
if_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'if' named_expression ':' block elif_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> if_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'if' named_expression ':' block elif_stmt"));
        Token * _keyword;
        Token * _literal;
        expr_ty a;
        asdl_seq* b;
        stmt_ty c;
        if (
            (_keyword = _PyPegen_expect_token(p, 510))  // token='if'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
            &&
            (c = elif_stmt_rule(p))  // elif_stmt
        )
        {
            D(fprintf(stderr, "%*c+ if_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'if' named_expression ':' block elif_stmt"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_If ( a , b , CHECK ( _PyPegen_singleton_seq ( p , c ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s if_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'if' named_expression ':' block elif_stmt"));
    }
    { // 'if' named_expression ':' block else_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> if_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'if' named_expression ':' block else_block?"));
        Token * _keyword;
        Token * _literal;
        expr_ty a;
        asdl_seq* b;
        void *c;
        if (
            (_keyword = _PyPegen_expect_token(p, 510))  // token='if'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
            &&
            (c = else_block_rule(p), !p->error_indicator)  // else_block?
        )
        {
            D(fprintf(stderr, "%*c+ if_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'if' named_expression ':' block else_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_If ( a , b , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s if_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'if' named_expression ':' block else_block?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// elif_stmt:
//     | 'elif' named_expression ':' block elif_stmt
//     | 'elif' named_expression ':' block else_block?
static stmt_ty
elif_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'elif' named_expression ':' block elif_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> elif_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'elif' named_expression ':' block elif_stmt"));
        Token * _keyword;
        Token * _literal;
        expr_ty a;
        asdl_seq* b;
        stmt_ty c;
        if (
            (_keyword = _PyPegen_expect_token(p, 515))  // token='elif'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
            &&
            (c = elif_stmt_rule(p))  // elif_stmt
        )
        {
            D(fprintf(stderr, "%*c+ elif_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'elif' named_expression ':' block elif_stmt"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_If ( a , b , CHECK ( _PyPegen_singleton_seq ( p , c ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s elif_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'elif' named_expression ':' block elif_stmt"));
    }
    { // 'elif' named_expression ':' block else_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> elif_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'elif' named_expression ':' block else_block?"));
        Token * _keyword;
        Token * _literal;
        expr_ty a;
        asdl_seq* b;
        void *c;
        if (
            (_keyword = _PyPegen_expect_token(p, 515))  // token='elif'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
            &&
            (c = else_block_rule(p), !p->error_indicator)  // else_block?
        )
        {
            D(fprintf(stderr, "%*c+ elif_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'elif' named_expression ':' block else_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_If ( a , b , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s elif_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'elif' named_expression ':' block else_block?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// else_block: 'else' ':' block
static asdl_seq*
else_block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // 'else' ':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> else_block[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'else' ':' block"));
        Token * _keyword;
        Token * _literal;
        asdl_seq* b;
        if (
            (_keyword = _PyPegen_expect_token(p, 516))  // token='else'
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ else_block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'else' ':' block"));
            _res = b;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s else_block[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'else' ':' block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// while_stmt: 'while' named_expression ':' block else_block?
static stmt_ty
while_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'while' named_expression ':' block else_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> while_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'while' named_expression ':' block else_block?"));
        Token * _keyword;
        Token * _literal;
        expr_ty a;
        asdl_seq* b;
        void *c;
        if (
            (_keyword = _PyPegen_expect_token(p, 512))  // token='while'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
            &&
            (c = else_block_rule(p), !p->error_indicator)  // else_block?
        )
        {
            D(fprintf(stderr, "%*c+ while_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'while' named_expression ':' block else_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_While ( a , b , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s while_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'while' named_expression ':' block else_block?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// for_stmt:
//     | 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
//     | ASYNC 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
//     | invalid_for_target
static stmt_ty
for_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
        int _cut_var = 0;
        Token * _keyword;
        Token * _keyword_1;
        Token * _literal;
        asdl_seq* b;
        void *el;
        expr_ty ex;
        expr_ty t;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 517))  // token='for'
            &&
            (t = star_targets_rule(p))  // star_targets
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 518))  // token='in'
            &&
            (_cut_var = 1)
            &&
            (ex = star_expressions_rule(p))  // star_expressions
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_rule(p))  // block
            &&
            (el = else_block_rule(p), !p->error_indicator)  // else_block?
        )
        {
            D(fprintf(stderr, "%*c+ for_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_For ( t , ex , b , el , NEW_TYPE_COMMENT ( p , tc ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    { // ASYNC 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "ASYNC 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
        int _cut_var = 0;
        Token * _keyword;
        Token * _keyword_1;
        Token * _literal;
        Token * async_var;
        asdl_seq* b;
        void *el;
        expr_ty ex;
        expr_ty t;
        void *tc;
        if (
            (async_var = _PyPegen_expect_token(p, ASYNC))  // token='ASYNC'
            &&
            (_keyword = _PyPegen_expect_token(p, 517))  // token='for'
            &&
            (t = star_targets_rule(p))  // star_targets
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 518))  // token='in'
            &&
            (_cut_var = 1)
            &&
            (ex = star_expressions_rule(p))  // star_expressions
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_rule(p))  // block
            &&
            (el = else_block_rule(p), !p->error_indicator)  // else_block?
        )
        {
            D(fprintf(stderr, "%*c+ for_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "ASYNC 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( 5 , "Async for loops are" , _Py_AsyncFor ( t , ex , b , el , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "ASYNC 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    if (p->call_invalid_rules) { // invalid_for_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_for_target"));
        void *invalid_for_target_var;
        if (
            (invalid_for_target_var = invalid_for_target_rule(p))  // invalid_for_target
        )
        {
            D(fprintf(stderr, "%*c+ for_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_for_target"));
            _res = invalid_for_target_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_for_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// with_stmt:
//     | 'with' '(' ','.with_item+ ','? ')' ':' block
//     | 'with' ','.with_item+ ':' TYPE_COMMENT? block
//     | ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block
//     | ASYNC 'with' ','.with_item+ ':' TYPE_COMMENT? block
static stmt_ty
with_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'with' '(' ','.with_item+ ','? ')' ':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'with' '(' ','.with_item+ ','? ')' ':' block"));
        Token * _keyword;
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_seq * a;
        asdl_seq* b;
        if (
            (_keyword = _PyPegen_expect_token(p, 519))  // token='with'
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = _gather_39_rule(p))  // ','.with_item+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (_literal_2 = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'with' '(' ','.with_item+ ','? ')' ':' block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_With ( a , b , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'with' '(' ','.with_item+ ','? ')' ':' block"));
    }
    { // 'with' ','.with_item+ ':' TYPE_COMMENT? block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'with' ','.with_item+ ':' TYPE_COMMENT? block"));
        Token * _keyword;
        Token * _literal;
        asdl_seq * a;
        asdl_seq* b;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 519))  // token='with'
            &&
            (a = _gather_41_rule(p))  // ','.with_item+
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'with' ','.with_item+ ':' TYPE_COMMENT? block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_With ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'with' ','.with_item+ ':' TYPE_COMMENT? block"));
    }
    { // ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block"));
        Token * _keyword;
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_seq * a;
        Token * async_var;
        asdl_seq* b;
        if (
            (async_var = _PyPegen_expect_token(p, ASYNC))  // token='ASYNC'
            &&
            (_keyword = _PyPegen_expect_token(p, 519))  // token='with'
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = _gather_43_rule(p))  // ','.with_item+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (_literal_2 = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( 5 , "Async with statements are" , _Py_AsyncWith ( a , b , NULL , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block"));
    }
    { // ASYNC 'with' ','.with_item+ ':' TYPE_COMMENT? block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "ASYNC 'with' ','.with_item+ ':' TYPE_COMMENT? block"));
        Token * _keyword;
        Token * _literal;
        asdl_seq * a;
        Token * async_var;
        asdl_seq* b;
        void *tc;
        if (
            (async_var = _PyPegen_expect_token(p, ASYNC))  // token='ASYNC'
            &&
            (_keyword = _PyPegen_expect_token(p, 519))  // token='with'
            &&
            (a = _gather_45_rule(p))  // ','.with_item+
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "ASYNC 'with' ','.with_item+ ':' TYPE_COMMENT? block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( 5 , "Async with statements are" , _Py_AsyncWith ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "ASYNC 'with' ','.with_item+ ':' TYPE_COMMENT? block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// with_item:
//     | expression 'as' star_target &(',' | ')' | ':')
//     | invalid_with_item
//     | expression
static withitem_ty
with_item_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    withitem_ty _res = NULL;
    int _mark = p->mark;
    { // expression 'as' star_target &(',' | ')' | ':')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_item[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression 'as' star_target &(',' | ')' | ':')"));
        Token * _keyword;
        expr_ty e;
        expr_ty t;
        if (
            (e = expression_rule(p))  // expression
            &&
            (_keyword = _PyPegen_expect_token(p, 520))  // token='as'
            &&
            (t = star_target_rule(p))  // star_target
            &&
            _PyPegen_lookahead(1, _tmp_47_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ with_item[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression 'as' star_target &(',' | ')' | ':')"));
            _res = _Py_withitem ( e , t , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_item[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression 'as' star_target &(',' | ')' | ':')"));
    }
    if (p->call_invalid_rules) { // invalid_with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_item[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_with_item"));
        void *invalid_with_item_var;
        if (
            (invalid_with_item_var = invalid_with_item_rule(p))  // invalid_with_item
        )
        {
            D(fprintf(stderr, "%*c+ with_item[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_with_item"));
            _res = invalid_with_item_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_item[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_with_item"));
    }
    { // expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_item[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression"));
        expr_ty e;
        if (
            (e = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ with_item[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression"));
            _res = _Py_withitem ( e , NULL , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_item[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// try_stmt:
//     | 'try' ':' block finally_block
//     | 'try' ':' block except_block+ else_block? finally_block?
static stmt_ty
try_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'try' ':' block finally_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> try_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'try' ':' block finally_block"));
        Token * _keyword;
        Token * _literal;
        asdl_seq* b;
        asdl_seq* f;
        if (
            (_keyword = _PyPegen_expect_token(p, 511))  // token='try'
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
            &&
            (f = finally_block_rule(p))  // finally_block
        )
        {
            D(fprintf(stderr, "%*c+ try_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'try' ':' block finally_block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Try ( b , NULL , NULL , f , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s try_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'try' ':' block finally_block"));
    }
    { // 'try' ':' block except_block+ else_block? finally_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> try_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'try' ':' block except_block+ else_block? finally_block?"));
        Token * _keyword;
        Token * _literal;
        asdl_seq* b;
        void *el;
        asdl_seq * ex;
        void *f;
        if (
            (_keyword = _PyPegen_expect_token(p, 511))  // token='try'
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
            &&
            (ex = _loop1_48_rule(p))  // except_block+
            &&
            (el = else_block_rule(p), !p->error_indicator)  // else_block?
            &&
            (f = finally_block_rule(p), !p->error_indicator)  // finally_block?
        )
        {
            D(fprintf(stderr, "%*c+ try_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'try' ':' block except_block+ else_block? finally_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Try ( b , ex , el , f , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s try_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'try' ':' block except_block+ else_block? finally_block?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// except_block: 'except' expression ['as' NAME] ':' block | 'except' ':' block
static excepthandler_ty
except_block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    excepthandler_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'except' expression ['as' NAME] ':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> except_block[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'except' expression ['as' NAME] ':' block"));
        Token * _keyword;
        Token * _literal;
        asdl_seq* b;
        expr_ty e;
        void *t;
        if (
            (_keyword = _PyPegen_expect_token(p, 521))  // token='except'
            &&
            (e = expression_rule(p))  // expression
            &&
            (t = _tmp_49_rule(p), !p->error_indicator)  // ['as' NAME]
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ except_block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'except' expression ['as' NAME] ':' block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_ExceptHandler ( e , ( t ) ? ( ( expr_ty ) t ) -> v . Name . id : NULL , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s except_block[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'except' expression ['as' NAME] ':' block"));
    }
    { // 'except' ':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> except_block[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'except' ':' block"));
        Token * _keyword;
        Token * _literal;
        asdl_seq* b;
        if (
            (_keyword = _PyPegen_expect_token(p, 521))  // token='except'
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ except_block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'except' ':' block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_ExceptHandler ( NULL , NULL , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s except_block[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'except' ':' block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// finally_block: 'finally' ':' block
static asdl_seq*
finally_block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // 'finally' ':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> finally_block[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'finally' ':' block"));
        Token * _keyword;
        Token * _literal;
        asdl_seq* a;
        if (
            (_keyword = _PyPegen_expect_token(p, 522))  // token='finally'
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (a = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ finally_block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'finally' ':' block"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s finally_block[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'finally' ':' block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// return_stmt: 'return' star_expressions?
static stmt_ty
return_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'return' star_expressions?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> return_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'return' star_expressions?"));
        Token * _keyword;
        void *a;
        if (
            (_keyword = _PyPegen_expect_token(p, 500))  // token='return'
            &&
            (a = star_expressions_rule(p), !p->error_indicator)  // star_expressions?
        )
        {
            D(fprintf(stderr, "%*c+ return_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'return' star_expressions?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Return ( a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s return_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'return' star_expressions?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// raise_stmt: 'raise' expression ['from' expression] | 'raise'
static stmt_ty
raise_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'raise' expression ['from' expression]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> raise_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'raise' expression ['from' expression]"));
        Token * _keyword;
        expr_ty a;
        void *b;
        if (
            (_keyword = _PyPegen_expect_token(p, 501))  // token='raise'
            &&
            (a = expression_rule(p))  // expression
            &&
            (b = _tmp_50_rule(p), !p->error_indicator)  // ['from' expression]
        )
        {
            D(fprintf(stderr, "%*c+ raise_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'raise' expression ['from' expression]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Raise ( a , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s raise_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'raise' expression ['from' expression]"));
    }
    { // 'raise'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> raise_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'raise'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 501))  // token='raise'
        )
        {
            D(fprintf(stderr, "%*c+ raise_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'raise'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Raise ( NULL , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s raise_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'raise'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// function_def: decorators function_def_raw | function_def_raw
static stmt_ty
function_def_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    { // decorators function_def_raw
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> function_def[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "decorators function_def_raw"));
        asdl_seq* d;
        stmt_ty f;
        if (
            (d = decorators_rule(p))  // decorators
            &&
            (f = function_def_raw_rule(p))  // function_def_raw
        )
        {
            D(fprintf(stderr, "%*c+ function_def[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "decorators function_def_raw"));
            _res = _PyPegen_function_def_decorators ( p , d , f );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s function_def[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "decorators function_def_raw"));
    }
    { // function_def_raw
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> function_def[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "function_def_raw"));
        stmt_ty function_def_raw_var;
        if (
            (function_def_raw_var = function_def_raw_rule(p))  // function_def_raw
        )
        {
            D(fprintf(stderr, "%*c+ function_def[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "function_def_raw"));
            _res = function_def_raw_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s function_def[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "function_def_raw"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// function_def_raw:
//     | 'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block
//     | ASYNC 'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block
static stmt_ty
function_def_raw_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> function_def_raw[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block"));
        Token * _keyword;
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        void *a;
        asdl_seq* b;
        expr_ty n;
        void *params;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 523))  // token='def'
            &&
            (n = _PyPegen_name_token(p))  // NAME
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (params = params_rule(p), !p->error_indicator)  // params?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (a = _tmp_51_rule(p), !p->error_indicator)  // ['->' expression]
            &&
            (_literal_2 = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (tc = func_type_comment_rule(p), !p->error_indicator)  // func_type_comment?
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ function_def_raw[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_FunctionDef ( n -> v . Name . id , ( params ) ? params : CHECK ( _PyPegen_empty_arguments ( p ) ) , b , NULL , a , NEW_TYPE_COMMENT ( p , tc ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s function_def_raw[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block"));
    }
    { // ASYNC 'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> function_def_raw[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "ASYNC 'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block"));
        Token * _keyword;
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        void *a;
        Token * async_var;
        asdl_seq* b;
        expr_ty n;
        void *params;
        void *tc;
        if (
            (async_var = _PyPegen_expect_token(p, ASYNC))  // token='ASYNC'
            &&
            (_keyword = _PyPegen_expect_token(p, 523))  // token='def'
            &&
            (n = _PyPegen_name_token(p))  // NAME
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (params = params_rule(p), !p->error_indicator)  // params?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (a = _tmp_52_rule(p), !p->error_indicator)  // ['->' expression]
            &&
            (_literal_2 = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (tc = func_type_comment_rule(p), !p->error_indicator)  // func_type_comment?
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ function_def_raw[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "ASYNC 'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( 5 , "Async functions are" , _Py_AsyncFunctionDef ( n -> v . Name . id , ( params ) ? params : CHECK ( _PyPegen_empty_arguments ( p ) ) , b , NULL , a , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s function_def_raw[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "ASYNC 'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// func_type_comment:
//     | NEWLINE TYPE_COMMENT &(NEWLINE INDENT)
//     | invalid_double_type_comments
//     | TYPE_COMMENT
static Token*
func_type_comment_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    Token* _res = NULL;
    int _mark = p->mark;
    { // NEWLINE TYPE_COMMENT &(NEWLINE INDENT)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> func_type_comment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NEWLINE TYPE_COMMENT &(NEWLINE INDENT)"));
        Token * newline_var;
        Token * t;
        if (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (t = _PyPegen_expect_token(p, TYPE_COMMENT))  // token='TYPE_COMMENT'
            &&
            _PyPegen_lookahead(1, _tmp_53_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ func_type_comment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NEWLINE TYPE_COMMENT &(NEWLINE INDENT)"));
            _res = t;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s func_type_comment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NEWLINE TYPE_COMMENT &(NEWLINE INDENT)"));
    }
    if (p->call_invalid_rules) { // invalid_double_type_comments
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> func_type_comment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_double_type_comments"));
        void *invalid_double_type_comments_var;
        if (
            (invalid_double_type_comments_var = invalid_double_type_comments_rule(p))  // invalid_double_type_comments
        )
        {
            D(fprintf(stderr, "%*c+ func_type_comment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_double_type_comments"));
            _res = invalid_double_type_comments_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s func_type_comment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_double_type_comments"));
    }
    { // TYPE_COMMENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> func_type_comment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "TYPE_COMMENT"));
        Token * type_comment_var;
        if (
            (type_comment_var = _PyPegen_expect_token(p, TYPE_COMMENT))  // token='TYPE_COMMENT'
        )
        {
            D(fprintf(stderr, "%*c+ func_type_comment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "TYPE_COMMENT"));
            _res = type_comment_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s func_type_comment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "TYPE_COMMENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// params: invalid_parameters | parameters
static arguments_ty
params_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arguments_ty _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_parameters
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> params[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_parameters"));
        void *invalid_parameters_var;
        if (
            (invalid_parameters_var = invalid_parameters_rule(p))  // invalid_parameters
        )
        {
            D(fprintf(stderr, "%*c+ params[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_parameters"));
            _res = invalid_parameters_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s params[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_parameters"));
    }
    { // parameters
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> params[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "parameters"));
        arguments_ty parameters_var;
        if (
            (parameters_var = parameters_rule(p))  // parameters
        )
        {
            D(fprintf(stderr, "%*c+ params[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "parameters"));
            _res = parameters_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s params[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "parameters"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// parameters:
//     | slash_no_default param_no_default* param_with_default* star_etc?
//     | slash_with_default param_with_default* star_etc?
//     | param_no_default+ param_with_default* star_etc?
//     | param_with_default+ star_etc?
//     | star_etc
static arguments_ty
parameters_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arguments_ty _res = NULL;
    int _mark = p->mark;
    { // slash_no_default param_no_default* param_with_default* star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> parameters[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "slash_no_default param_no_default* param_with_default* star_etc?"));
        asdl_seq* a;
        asdl_seq * b;
        asdl_seq * c;
        void *d;
        if (
            (a = slash_no_default_rule(p))  // slash_no_default
            &&
            (b = _loop0_54_rule(p))  // param_no_default*
            &&
            (c = _loop0_55_rule(p))  // param_with_default*
            &&
            (d = star_etc_rule(p), !p->error_indicator)  // star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ parameters[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "slash_no_default param_no_default* param_with_default* star_etc?"));
            _res = _PyPegen_make_arguments ( p , a , NULL , b , c , d );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s parameters[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "slash_no_default param_no_default* param_with_default* star_etc?"));
    }
    { // slash_with_default param_with_default* star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> parameters[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "slash_with_default param_with_default* star_etc?"));
        SlashWithDefault* a;
        asdl_seq * b;
        void *c;
        if (
            (a = slash_with_default_rule(p))  // slash_with_default
            &&
            (b = _loop0_56_rule(p))  // param_with_default*
            &&
            (c = star_etc_rule(p), !p->error_indicator)  // star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ parameters[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "slash_with_default param_with_default* star_etc?"));
            _res = _PyPegen_make_arguments ( p , NULL , a , NULL , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s parameters[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "slash_with_default param_with_default* star_etc?"));
    }
    { // param_no_default+ param_with_default* star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> parameters[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_no_default+ param_with_default* star_etc?"));
        asdl_seq * a;
        asdl_seq * b;
        void *c;
        if (
            (a = _loop1_57_rule(p))  // param_no_default+
            &&
            (b = _loop0_58_rule(p))  // param_with_default*
            &&
            (c = star_etc_rule(p), !p->error_indicator)  // star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ parameters[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "param_no_default+ param_with_default* star_etc?"));
            _res = _PyPegen_make_arguments ( p , NULL , NULL , a , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s parameters[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_no_default+ param_with_default* star_etc?"));
    }
    { // param_with_default+ star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> parameters[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_with_default+ star_etc?"));
        asdl_seq * a;
        void *b;
        if (
            (a = _loop1_59_rule(p))  // param_with_default+
            &&
            (b = star_etc_rule(p), !p->error_indicator)  // star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ parameters[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "param_with_default+ star_etc?"));
            _res = _PyPegen_make_arguments ( p , NULL , NULL , NULL , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s parameters[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_with_default+ star_etc?"));
    }
    { // star_etc
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> parameters[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_etc"));
        StarEtc* a;
        if (
            (a = star_etc_rule(p))  // star_etc
        )
        {
            D(fprintf(stderr, "%*c+ parameters[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_etc"));
            _res = _PyPegen_make_arguments ( p , NULL , NULL , NULL , NULL , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s parameters[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_etc"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// slash_no_default: param_no_default+ '/' ',' | param_no_default+ '/' &')'
static asdl_seq*
slash_no_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // param_no_default+ '/' ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> slash_no_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_no_default+ '/' ','"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * a;
        if (
            (a = _loop1_60_rule(p))  // param_no_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ slash_no_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "param_no_default+ '/' ','"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s slash_no_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_no_default+ '/' ','"));
    }
    { // param_no_default+ '/' &')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> slash_no_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_no_default+ '/' &')'"));
        Token * _literal;
        asdl_seq * a;
        if (
            (a = _loop1_61_rule(p))  // param_no_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ slash_no_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "param_no_default+ '/' &')'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s slash_no_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_no_default+ '/' &')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// slash_with_default:
//     | param_no_default* param_with_default+ '/' ','
//     | param_no_default* param_with_default+ '/' &')'
static SlashWithDefault*
slash_with_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    SlashWithDefault* _res = NULL;
    int _mark = p->mark;
    { // param_no_default* param_with_default+ '/' ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> slash_with_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_no_default* param_with_default+ '/' ','"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * a;
        asdl_seq * b;
        if (
            (a = _loop0_62_rule(p))  // param_no_default*
            &&
            (b = _loop1_63_rule(p))  // param_with_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ slash_with_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "param_no_default* param_with_default+ '/' ','"));
            _res = _PyPegen_slash_with_default ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s slash_with_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_no_default* param_with_default+ '/' ','"));
    }
    { // param_no_default* param_with_default+ '/' &')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> slash_with_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_no_default* param_with_default+ '/' &')'"));
        Token * _literal;
        asdl_seq * a;
        asdl_seq * b;
        if (
            (a = _loop0_64_rule(p))  // param_no_default*
            &&
            (b = _loop1_65_rule(p))  // param_with_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ slash_with_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "param_no_default* param_with_default+ '/' &')'"));
            _res = _PyPegen_slash_with_default ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s slash_with_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_no_default* param_with_default+ '/' &')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_etc:
//     | '*' param_no_default param_maybe_default* kwds?
//     | '*' ',' param_maybe_default+ kwds?
//     | kwds
//     | invalid_star_etc
static StarEtc*
star_etc_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    StarEtc* _res = NULL;
    int _mark = p->mark;
    { // '*' param_no_default param_maybe_default* kwds?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_etc[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*' param_no_default param_maybe_default* kwds?"));
        Token * _literal;
        arg_ty a;
        asdl_seq * b;
        void *c;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = param_no_default_rule(p))  // param_no_default
            &&
            (b = _loop0_66_rule(p))  // param_maybe_default*
            &&
            (c = kwds_rule(p), !p->error_indicator)  // kwds?
        )
        {
            D(fprintf(stderr, "%*c+ star_etc[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' param_no_default param_maybe_default* kwds?"));
            _res = _PyPegen_star_etc ( p , a , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_etc[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*' param_no_default param_maybe_default* kwds?"));
    }
    { // '*' ',' param_maybe_default+ kwds?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_etc[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*' ',' param_maybe_default+ kwds?"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * b;
        void *c;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (b = _loop1_67_rule(p))  // param_maybe_default+
            &&
            (c = kwds_rule(p), !p->error_indicator)  // kwds?
        )
        {
            D(fprintf(stderr, "%*c+ star_etc[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' ',' param_maybe_default+ kwds?"));
            _res = _PyPegen_star_etc ( p , NULL , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_etc[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*' ',' param_maybe_default+ kwds?"));
    }
    { // kwds
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_etc[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "kwds"));
        arg_ty a;
        if (
            (a = kwds_rule(p))  // kwds
        )
        {
            D(fprintf(stderr, "%*c+ star_etc[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "kwds"));
            _res = _PyPegen_star_etc ( p , NULL , NULL , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_etc[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "kwds"));
    }
    if (p->call_invalid_rules) { // invalid_star_etc
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_etc[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_star_etc"));
        void *invalid_star_etc_var;
        if (
            (invalid_star_etc_var = invalid_star_etc_rule(p))  // invalid_star_etc
        )
        {
            D(fprintf(stderr, "%*c+ star_etc[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_star_etc"));
            _res = invalid_star_etc_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_etc[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_star_etc"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// kwds: '**' param_no_default
static arg_ty
kwds_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    { // '**' param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwds[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'**' param_no_default"));
        Token * _literal;
        arg_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (a = param_no_default_rule(p))  // param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ kwds[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'**' param_no_default"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwds[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'**' param_no_default"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// param_no_default: param ',' TYPE_COMMENT? | param TYPE_COMMENT? &')'
static arg_ty
param_no_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    { // param ',' TYPE_COMMENT?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> param_no_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param ',' TYPE_COMMENT?"));
        Token * _literal;
        arg_ty a;
        void *tc;
        if (
            (a = param_rule(p))  // param
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
        )
        {
            D(fprintf(stderr, "%*c+ param_no_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "param ',' TYPE_COMMENT?"));
            _res = _PyPegen_add_type_comment_to_arg ( p , a , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s param_no_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param ',' TYPE_COMMENT?"));
    }
    { // param TYPE_COMMENT? &')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> param_no_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param TYPE_COMMENT? &')'"));
        arg_ty a;
        void *tc;
        if (
            (a = param_rule(p))  // param
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ param_no_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "param TYPE_COMMENT? &')'"));
            _res = _PyPegen_add_type_comment_to_arg ( p , a , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s param_no_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param TYPE_COMMENT? &')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// param_with_default: param default ',' TYPE_COMMENT? | param default TYPE_COMMENT? &')'
static NameDefaultPair*
param_with_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    NameDefaultPair* _res = NULL;
    int _mark = p->mark;
    { // param default ',' TYPE_COMMENT?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> param_with_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param default ',' TYPE_COMMENT?"));
        Token * _literal;
        arg_ty a;
        expr_ty c;
        void *tc;
        if (
            (a = param_rule(p))  // param
            &&
            (c = default_rule(p))  // default
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
        )
        {
            D(fprintf(stderr, "%*c+ param_with_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "param default ',' TYPE_COMMENT?"));
            _res = _PyPegen_name_default_pair ( p , a , c , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s param_with_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param default ',' TYPE_COMMENT?"));
    }
    { // param default TYPE_COMMENT? &')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> param_with_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param default TYPE_COMMENT? &')'"));
        arg_ty a;
        expr_ty c;
        void *tc;
        if (
            (a = param_rule(p))  // param
            &&
            (c = default_rule(p))  // default
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ param_with_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "param default TYPE_COMMENT? &')'"));
            _res = _PyPegen_name_default_pair ( p , a , c , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s param_with_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param default TYPE_COMMENT? &')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// param_maybe_default:
//     | param default? ',' TYPE_COMMENT?
//     | param default? TYPE_COMMENT? &')'
static NameDefaultPair*
param_maybe_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    NameDefaultPair* _res = NULL;
    int _mark = p->mark;
    { // param default? ',' TYPE_COMMENT?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> param_maybe_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param default? ',' TYPE_COMMENT?"));
        Token * _literal;
        arg_ty a;
        void *c;
        void *tc;
        if (
            (a = param_rule(p))  // param
            &&
            (c = default_rule(p), !p->error_indicator)  // default?
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
        )
        {
            D(fprintf(stderr, "%*c+ param_maybe_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "param default? ',' TYPE_COMMENT?"));
            _res = _PyPegen_name_default_pair ( p , a , c , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s param_maybe_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param default? ',' TYPE_COMMENT?"));
    }
    { // param default? TYPE_COMMENT? &')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> param_maybe_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param default? TYPE_COMMENT? &')'"));
        arg_ty a;
        void *c;
        void *tc;
        if (
            (a = param_rule(p))  // param
            &&
            (c = default_rule(p), !p->error_indicator)  // default?
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ param_maybe_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "param default? TYPE_COMMENT? &')'"));
            _res = _PyPegen_name_default_pair ( p , a , c , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s param_maybe_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param default? TYPE_COMMENT? &')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// param: NAME annotation?
static arg_ty
param_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME annotation?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> param[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NAME annotation?"));
        expr_ty a;
        void *b;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (b = annotation_rule(p), !p->error_indicator)  // annotation?
        )
        {
            D(fprintf(stderr, "%*c+ param[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME annotation?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_arg ( a -> v . Name . id , b , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s param[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NAME annotation?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// annotation: ':' expression
static expr_ty
annotation_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // ':' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> annotation[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "':' expression"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ annotation[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "':' expression"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s annotation[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "':' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// default: '=' expression
static expr_ty
default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // '=' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'=' expression"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'=' expression"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'=' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// decorators: (('@' named_expression NEWLINE))+
static asdl_seq*
decorators_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // (('@' named_expression NEWLINE))+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> decorators[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "(('@' named_expression NEWLINE))+"));
        asdl_seq * a;
        if (
            (a = _loop1_68_rule(p))  // (('@' named_expression NEWLINE))+
        )
        {
            D(fprintf(stderr, "%*c+ decorators[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "(('@' named_expression NEWLINE))+"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s decorators[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "(('@' named_expression NEWLINE))+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// class_def: decorators class_def_raw | class_def_raw
static stmt_ty
class_def_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    { // decorators class_def_raw
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> class_def[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "decorators class_def_raw"));
        asdl_seq* a;
        stmt_ty b;
        if (
            (a = decorators_rule(p))  // decorators
            &&
            (b = class_def_raw_rule(p))  // class_def_raw
        )
        {
            D(fprintf(stderr, "%*c+ class_def[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "decorators class_def_raw"));
            _res = _PyPegen_class_def_decorators ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s class_def[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "decorators class_def_raw"));
    }
    { // class_def_raw
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> class_def[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "class_def_raw"));
        stmt_ty class_def_raw_var;
        if (
            (class_def_raw_var = class_def_raw_rule(p))  // class_def_raw
        )
        {
            D(fprintf(stderr, "%*c+ class_def[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "class_def_raw"));
            _res = class_def_raw_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s class_def[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "class_def_raw"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// class_def_raw: 'class' NAME ['(' arguments? ')'] ':' block
static stmt_ty
class_def_raw_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'class' NAME ['(' arguments? ')'] ':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> class_def_raw[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'class' NAME ['(' arguments? ')'] ':' block"));
        Token * _keyword;
        Token * _literal;
        expr_ty a;
        void *b;
        asdl_seq* c;
        if (
            (_keyword = _PyPegen_expect_token(p, 524))  // token='class'
            &&
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (b = _tmp_69_rule(p), !p->error_indicator)  // ['(' arguments? ')']
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (c = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ class_def_raw[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'class' NAME ['(' arguments? ')'] ':' block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_ClassDef ( a -> v . Name . id , ( b ) ? ( ( expr_ty ) b ) -> v . Call . args : NULL , ( b ) ? ( ( expr_ty ) b ) -> v . Call . keywords : NULL , c , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s class_def_raw[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'class' NAME ['(' arguments? ')'] ':' block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// block: NEWLINE INDENT statements DEDENT | simple_stmt | invalid_block
static asdl_seq*
block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    if (_PyPegen_is_memoized(p, block_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    { // NEWLINE INDENT statements DEDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> block[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NEWLINE INDENT statements DEDENT"));
        asdl_seq* a;
        Token * dedent_var;
        Token * indent_var;
        Token * newline_var;
        if (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (indent_var = _PyPegen_expect_token(p, INDENT))  // token='INDENT'
            &&
            (a = statements_rule(p))  // statements
            &&
            (dedent_var = _PyPegen_expect_token(p, DEDENT))  // token='DEDENT'
        )
        {
            D(fprintf(stderr, "%*c+ block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NEWLINE INDENT statements DEDENT"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s block[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NEWLINE INDENT statements DEDENT"));
    }
    { // simple_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> block[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "simple_stmt"));
        asdl_seq* simple_stmt_var;
        if (
            (simple_stmt_var = simple_stmt_rule(p))  // simple_stmt
        )
        {
            D(fprintf(stderr, "%*c+ block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "simple_stmt"));
            _res = simple_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s block[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "simple_stmt"));
    }
    if (p->call_invalid_rules) { // invalid_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> block[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_block"));
        void *invalid_block_var;
        if (
            (invalid_block_var = invalid_block_rule(p))  // invalid_block
        )
        {
            D(fprintf(stderr, "%*c+ block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_block"));
            _res = invalid_block_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s block[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_block"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, block_type, _res);
    p->level--;
    return _res;
}

// star_expressions:
//     | star_expression ((',' star_expression))+ ','?
//     | star_expression ','
//     | star_expression
static expr_ty
star_expressions_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // star_expression ((',' star_expression))+ ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_expression ((',' star_expression))+ ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty a;
        asdl_seq * b;
        if (
            (a = star_expression_rule(p))  // star_expression
            &&
            (b = _loop1_70_rule(p))  // ((',' star_expression))+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ star_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_expression ((',' star_expression))+ ','?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Tuple ( CHECK ( _PyPegen_seq_insert_in_front ( p , a , b ) ) , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_expression ((',' star_expression))+ ','?"));
    }
    { // star_expression ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_expression ','"));
        Token * _literal;
        expr_ty a;
        if (
            (a = star_expression_rule(p))  // star_expression
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ star_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_expression ','"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Tuple ( CHECK ( _PyPegen_singleton_seq ( p , a ) ) , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_expression ','"));
    }
    { // star_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_expression"));
        expr_ty star_expression_var;
        if (
            (star_expression_var = star_expression_rule(p))  // star_expression
        )
        {
            D(fprintf(stderr, "%*c+ star_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_expression"));
            _res = star_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_expression: '*' bitwise_or | expression
static expr_ty
star_expression_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, star_expression_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '*' bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_expression[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*' bitwise_or"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ star_expression[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' bitwise_or"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Starred ( a , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_expression[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*' bitwise_or"));
    }
    { // expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_expression[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression"));
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ star_expression[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression"));
            _res = expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_expression[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, star_expression_type, _res);
    p->level--;
    return _res;
}

// star_named_expressions: ','.star_named_expression+ ','?
static asdl_seq*
star_named_expressions_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.star_named_expression+ ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_named_expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.star_named_expression+ ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_seq * a;
        if (
            (a = _gather_71_rule(p))  // ','.star_named_expression+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ star_named_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.star_named_expression+ ','?"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_named_expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.star_named_expression+ ','?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_named_expression: '*' bitwise_or | named_expression
static expr_ty
star_named_expression_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '*' bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_named_expression[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*' bitwise_or"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ star_named_expression[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' bitwise_or"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Starred ( a , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_named_expression[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*' bitwise_or"));
    }
    { // named_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_named_expression[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "named_expression"));
        expr_ty named_expression_var;
        if (
            (named_expression_var = named_expression_rule(p))  // named_expression
        )
        {
            D(fprintf(stderr, "%*c+ star_named_expression[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "named_expression"));
            _res = named_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_named_expression[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "named_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// named_expression: NAME ':=' ~ expression | expression !':=' | invalid_named_expression
static expr_ty
named_expression_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME ':=' ~ expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> named_expression[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NAME ':=' ~ expression"));
        int _cut_var = 0;
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (_literal = _PyPegen_expect_token(p, 53))  // token=':='
            &&
            (_cut_var = 1)
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ named_expression[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME ':=' ~ expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_NamedExpr ( CHECK ( _PyPegen_set_expr_context ( p , a , Store ) ) , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s named_expression[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NAME ':=' ~ expression"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    { // expression !':='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> named_expression[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression !':='"));
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 53)  // token=':='
        )
        {
            D(fprintf(stderr, "%*c+ named_expression[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression !':='"));
            _res = expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s named_expression[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression !':='"));
    }
    if (p->call_invalid_rules) { // invalid_named_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> named_expression[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_named_expression"));
        void *invalid_named_expression_var;
        if (
            (invalid_named_expression_var = invalid_named_expression_rule(p))  // invalid_named_expression
        )
        {
            D(fprintf(stderr, "%*c+ named_expression[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_named_expression"));
            _res = invalid_named_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s named_expression[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_named_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// annotated_rhs: yield_expr | star_expressions
static expr_ty
annotated_rhs_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // yield_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> annotated_rhs[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "yield_expr"));
        expr_ty yield_expr_var;
        if (
            (yield_expr_var = yield_expr_rule(p))  // yield_expr
        )
        {
            D(fprintf(stderr, "%*c+ annotated_rhs[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "yield_expr"));
            _res = yield_expr_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s annotated_rhs[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "yield_expr"));
    }
    { // star_expressions
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> annotated_rhs[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_expressions"));
        expr_ty star_expressions_var;
        if (
            (star_expressions_var = star_expressions_rule(p))  // star_expressions
        )
        {
            D(fprintf(stderr, "%*c+ annotated_rhs[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_expressions"));
            _res = star_expressions_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s annotated_rhs[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_expressions"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// expressions: expression ((',' expression))+ ','? | expression ',' | expression
static expr_ty
expressions_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // expression ((',' expression))+ ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression ((',' expression))+ ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty a;
        asdl_seq * b;
        if (
            (a = expression_rule(p))  // expression
            &&
            (b = _loop1_73_rule(p))  // ((',' expression))+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression ((',' expression))+ ','?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Tuple ( CHECK ( _PyPegen_seq_insert_in_front ( p , a , b ) ) , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression ((',' expression))+ ','?"));
    }
    { // expression ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression ','"));
        Token * _literal;
        expr_ty a;
        if (
            (a = expression_rule(p))  // expression
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression ','"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Tuple ( CHECK ( _PyPegen_singleton_seq ( p , a ) ) , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression ','"));
    }
    { // expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> expressions[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression"));
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression"));
            _res = expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s expressions[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// expression: disjunction 'if' disjunction 'else' expression | disjunction | lambdef
static expr_ty
expression_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, expression_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // disjunction 'if' disjunction 'else' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> expression[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "disjunction 'if' disjunction 'else' expression"));
        Token * _keyword;
        Token * _keyword_1;
        expr_ty a;
        expr_ty b;
        expr_ty c;
        if (
            (a = disjunction_rule(p))  // disjunction
            &&
            (_keyword = _PyPegen_expect_token(p, 510))  // token='if'
            &&
            (b = disjunction_rule(p))  // disjunction
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 516))  // token='else'
            &&
            (c = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ expression[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "disjunction 'if' disjunction 'else' expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_IfExp ( b , a , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s expression[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "disjunction 'if' disjunction 'else' expression"));
    }
    { // disjunction
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> expression[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "disjunction"));
        expr_ty disjunction_var;
        if (
            (disjunction_var = disjunction_rule(p))  // disjunction
        )
        {
            D(fprintf(stderr, "%*c+ expression[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "disjunction"));
            _res = disjunction_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s expression[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "disjunction"));
    }
    { // lambdef
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> expression[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambdef"));
        expr_ty lambdef_var;
        if (
            (lambdef_var = lambdef_rule(p))  // lambdef
        )
        {
            D(fprintf(stderr, "%*c+ expression[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambdef"));
            _res = lambdef_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s expression[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambdef"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, expression_type, _res);
    p->level--;
    return _res;
}

// lambdef: 'lambda' lambda_params? ':' expression
static expr_ty
lambdef_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'lambda' lambda_params? ':' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambdef[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'lambda' lambda_params? ':' expression"));
        Token * _keyword;
        Token * _literal;
        void *a;
        expr_ty b;
        if (
            (_keyword = _PyPegen_expect_token(p, 525))  // token='lambda'
            &&
            (a = lambda_params_rule(p), !p->error_indicator)  // lambda_params?
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ lambdef[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'lambda' lambda_params? ':' expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Lambda ( ( a ) ? a : CHECK ( _PyPegen_empty_arguments ( p ) ) , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambdef[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'lambda' lambda_params? ':' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_params: invalid_lambda_parameters | lambda_parameters
static arguments_ty
lambda_params_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arguments_ty _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_lambda_parameters
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_params[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_lambda_parameters"));
        void *invalid_lambda_parameters_var;
        if (
            (invalid_lambda_parameters_var = invalid_lambda_parameters_rule(p))  // invalid_lambda_parameters
        )
        {
            D(fprintf(stderr, "%*c+ lambda_params[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_lambda_parameters"));
            _res = invalid_lambda_parameters_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_params[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_lambda_parameters"));
    }
    { // lambda_parameters
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_params[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_parameters"));
        arguments_ty lambda_parameters_var;
        if (
            (lambda_parameters_var = lambda_parameters_rule(p))  // lambda_parameters
        )
        {
            D(fprintf(stderr, "%*c+ lambda_params[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_parameters"));
            _res = lambda_parameters_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_params[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_parameters"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_parameters:
//     | lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc?
//     | lambda_slash_with_default lambda_param_with_default* lambda_star_etc?
//     | lambda_param_no_default+ lambda_param_with_default* lambda_star_etc?
//     | lambda_param_with_default+ lambda_star_etc?
//     | lambda_star_etc
static arguments_ty
lambda_parameters_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arguments_ty _res = NULL;
    int _mark = p->mark;
    { // lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_parameters[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc?"));
        asdl_seq* a;
        asdl_seq * b;
        asdl_seq * c;
        void *d;
        if (
            (a = lambda_slash_no_default_rule(p))  // lambda_slash_no_default
            &&
            (b = _loop0_74_rule(p))  // lambda_param_no_default*
            &&
            (c = _loop0_75_rule(p))  // lambda_param_with_default*
            &&
            (d = lambda_star_etc_rule(p), !p->error_indicator)  // lambda_star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_parameters[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc?"));
            _res = _PyPegen_make_arguments ( p , a , NULL , b , c , d );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_parameters[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc?"));
    }
    { // lambda_slash_with_default lambda_param_with_default* lambda_star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_parameters[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_slash_with_default lambda_param_with_default* lambda_star_etc?"));
        SlashWithDefault* a;
        asdl_seq * b;
        void *c;
        if (
            (a = lambda_slash_with_default_rule(p))  // lambda_slash_with_default
            &&
            (b = _loop0_76_rule(p))  // lambda_param_with_default*
            &&
            (c = lambda_star_etc_rule(p), !p->error_indicator)  // lambda_star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_parameters[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_slash_with_default lambda_param_with_default* lambda_star_etc?"));
            _res = _PyPegen_make_arguments ( p , NULL , a , NULL , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_parameters[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_slash_with_default lambda_param_with_default* lambda_star_etc?"));
    }
    { // lambda_param_no_default+ lambda_param_with_default* lambda_star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_parameters[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default+ lambda_param_with_default* lambda_star_etc?"));
        asdl_seq * a;
        asdl_seq * b;
        void *c;
        if (
            (a = _loop1_77_rule(p))  // lambda_param_no_default+
            &&
            (b = _loop0_78_rule(p))  // lambda_param_with_default*
            &&
            (c = lambda_star_etc_rule(p), !p->error_indicator)  // lambda_star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_parameters[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default+ lambda_param_with_default* lambda_star_etc?"));
            _res = _PyPegen_make_arguments ( p , NULL , NULL , a , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_parameters[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_no_default+ lambda_param_with_default* lambda_star_etc?"));
    }
    { // lambda_param_with_default+ lambda_star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_parameters[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_with_default+ lambda_star_etc?"));
        asdl_seq * a;
        void *b;
        if (
            (a = _loop1_79_rule(p))  // lambda_param_with_default+
            &&
            (b = lambda_star_etc_rule(p), !p->error_indicator)  // lambda_star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_parameters[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_param_with_default+ lambda_star_etc?"));
            _res = _PyPegen_make_arguments ( p , NULL , NULL , NULL , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_parameters[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_with_default+ lambda_star_etc?"));
    }
    { // lambda_star_etc
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_parameters[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_star_etc"));
        StarEtc* a;
        if (
            (a = lambda_star_etc_rule(p))  // lambda_star_etc
        )
        {
            D(fprintf(stderr, "%*c+ lambda_parameters[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_star_etc"));
            _res = _PyPegen_make_arguments ( p , NULL , NULL , NULL , NULL , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_parameters[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_star_etc"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_slash_no_default:
//     | lambda_param_no_default+ '/' ','
//     | lambda_param_no_default+ '/' &':'
static asdl_seq*
lambda_slash_no_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // lambda_param_no_default+ '/' ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_slash_no_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default+ '/' ','"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * a;
        if (
            (a = _loop1_80_rule(p))  // lambda_param_no_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ lambda_slash_no_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default+ '/' ','"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_slash_no_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_no_default+ '/' ','"));
    }
    { // lambda_param_no_default+ '/' &':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_slash_no_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default+ '/' &':'"));
        Token * _literal;
        asdl_seq * a;
        if (
            (a = _loop1_81_rule(p))  // lambda_param_no_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 11)  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ lambda_slash_no_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default+ '/' &':'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_slash_no_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_no_default+ '/' &':'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_slash_with_default:
//     | lambda_param_no_default* lambda_param_with_default+ '/' ','
//     | lambda_param_no_default* lambda_param_with_default+ '/' &':'
static SlashWithDefault*
lambda_slash_with_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    SlashWithDefault* _res = NULL;
    int _mark = p->mark;
    { // lambda_param_no_default* lambda_param_with_default+ '/' ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_slash_with_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default* lambda_param_with_default+ '/' ','"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * a;
        asdl_seq * b;
        if (
            (a = _loop0_82_rule(p))  // lambda_param_no_default*
            &&
            (b = _loop1_83_rule(p))  // lambda_param_with_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ lambda_slash_with_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default* lambda_param_with_default+ '/' ','"));
            _res = _PyPegen_slash_with_default ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_slash_with_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_no_default* lambda_param_with_default+ '/' ','"));
    }
    { // lambda_param_no_default* lambda_param_with_default+ '/' &':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_slash_with_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default* lambda_param_with_default+ '/' &':'"));
        Token * _literal;
        asdl_seq * a;
        asdl_seq * b;
        if (
            (a = _loop0_84_rule(p))  // lambda_param_no_default*
            &&
            (b = _loop1_85_rule(p))  // lambda_param_with_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 11)  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ lambda_slash_with_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default* lambda_param_with_default+ '/' &':'"));
            _res = _PyPegen_slash_with_default ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_slash_with_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_no_default* lambda_param_with_default+ '/' &':'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_star_etc:
//     | '*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds?
//     | '*' ',' lambda_param_maybe_default+ lambda_kwds?
//     | lambda_kwds
//     | invalid_lambda_star_etc
static StarEtc*
lambda_star_etc_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    StarEtc* _res = NULL;
    int _mark = p->mark;
    { // '*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_star_etc[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds?"));
        Token * _literal;
        arg_ty a;
        asdl_seq * b;
        void *c;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = lambda_param_no_default_rule(p))  // lambda_param_no_default
            &&
            (b = _loop0_86_rule(p))  // lambda_param_maybe_default*
            &&
            (c = lambda_kwds_rule(p), !p->error_indicator)  // lambda_kwds?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_star_etc[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds?"));
            _res = _PyPegen_star_etc ( p , a , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_star_etc[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds?"));
    }
    { // '*' ',' lambda_param_maybe_default+ lambda_kwds?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_star_etc[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*' ',' lambda_param_maybe_default+ lambda_kwds?"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * b;
        void *c;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (b = _loop1_87_rule(p))  // lambda_param_maybe_default+
            &&
            (c = lambda_kwds_rule(p), !p->error_indicator)  // lambda_kwds?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_star_etc[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' ',' lambda_param_maybe_default+ lambda_kwds?"));
            _res = _PyPegen_star_etc ( p , NULL , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_star_etc[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*' ',' lambda_param_maybe_default+ lambda_kwds?"));
    }
    { // lambda_kwds
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_star_etc[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_kwds"));
        arg_ty a;
        if (
            (a = lambda_kwds_rule(p))  // lambda_kwds
        )
        {
            D(fprintf(stderr, "%*c+ lambda_star_etc[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_kwds"));
            _res = _PyPegen_star_etc ( p , NULL , NULL , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_star_etc[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_kwds"));
    }
    if (p->call_invalid_rules) { // invalid_lambda_star_etc
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_star_etc[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_lambda_star_etc"));
        void *invalid_lambda_star_etc_var;
        if (
            (invalid_lambda_star_etc_var = invalid_lambda_star_etc_rule(p))  // invalid_lambda_star_etc
        )
        {
            D(fprintf(stderr, "%*c+ lambda_star_etc[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_lambda_star_etc"));
            _res = invalid_lambda_star_etc_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_star_etc[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_lambda_star_etc"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_kwds: '**' lambda_param_no_default
static arg_ty
lambda_kwds_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    { // '**' lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_kwds[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'**' lambda_param_no_default"));
        Token * _literal;
        arg_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (a = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ lambda_kwds[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'**' lambda_param_no_default"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_kwds[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'**' lambda_param_no_default"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_param_no_default: lambda_param ',' | lambda_param &':'
static arg_ty
lambda_param_no_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    { // lambda_param ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_param_no_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param ','"));
        Token * _literal;
        arg_ty a;
        if (
            (a = lambda_param_rule(p))  // lambda_param
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ lambda_param_no_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_param ','"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_param_no_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param ','"));
    }
    { // lambda_param &':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_param_no_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param &':'"));
        arg_ty a;
        if (
            (a = lambda_param_rule(p))  // lambda_param
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 11)  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ lambda_param_no_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_param &':'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_param_no_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param &':'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_param_with_default: lambda_param default ',' | lambda_param default &':'
static NameDefaultPair*
lambda_param_with_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    NameDefaultPair* _res = NULL;
    int _mark = p->mark;
    { // lambda_param default ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_param_with_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param default ','"));
        Token * _literal;
        arg_ty a;
        expr_ty c;
        if (
            (a = lambda_param_rule(p))  // lambda_param
            &&
            (c = default_rule(p))  // default
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ lambda_param_with_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_param default ','"));
            _res = _PyPegen_name_default_pair ( p , a , c , NULL );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_param_with_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param default ','"));
    }
    { // lambda_param default &':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_param_with_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param default &':'"));
        arg_ty a;
        expr_ty c;
        if (
            (a = lambda_param_rule(p))  // lambda_param
            &&
            (c = default_rule(p))  // default
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 11)  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ lambda_param_with_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_param default &':'"));
            _res = _PyPegen_name_default_pair ( p , a , c , NULL );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_param_with_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param default &':'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_param_maybe_default: lambda_param default? ',' | lambda_param default? &':'
static NameDefaultPair*
lambda_param_maybe_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    NameDefaultPair* _res = NULL;
    int _mark = p->mark;
    { // lambda_param default? ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_param_maybe_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param default? ','"));
        Token * _literal;
        arg_ty a;
        void *c;
        if (
            (a = lambda_param_rule(p))  // lambda_param
            &&
            (c = default_rule(p), !p->error_indicator)  // default?
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ lambda_param_maybe_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_param default? ','"));
            _res = _PyPegen_name_default_pair ( p , a , c , NULL );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_param_maybe_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param default? ','"));
    }
    { // lambda_param default? &':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_param_maybe_default[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param default? &':'"));
        arg_ty a;
        void *c;
        if (
            (a = lambda_param_rule(p))  // lambda_param
            &&
            (c = default_rule(p), !p->error_indicator)  // default?
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 11)  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ lambda_param_maybe_default[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_param default? &':'"));
            _res = _PyPegen_name_default_pair ( p , a , c , NULL );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_param_maybe_default[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param default? &':'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_param: NAME
static arg_ty
lambda_param_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_param[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NAME"));
        expr_ty a;
        if (
            (a = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ lambda_param[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_arg ( a -> v . Name . id , NULL , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_param[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// disjunction: conjunction (('or' conjunction))+ | conjunction
static expr_ty
disjunction_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, disjunction_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // conjunction (('or' conjunction))+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> disjunction[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "conjunction (('or' conjunction))+"));
        expr_ty a;
        asdl_seq * b;
        if (
            (a = conjunction_rule(p))  // conjunction
            &&
            (b = _loop1_88_rule(p))  // (('or' conjunction))+
        )
        {
            D(fprintf(stderr, "%*c+ disjunction[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "conjunction (('or' conjunction))+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_BoolOp ( Or , CHECK ( _PyPegen_seq_insert_in_front ( p , a , b ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s disjunction[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "conjunction (('or' conjunction))+"));
    }
    { // conjunction
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> disjunction[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "conjunction"));
        expr_ty conjunction_var;
        if (
            (conjunction_var = conjunction_rule(p))  // conjunction
        )
        {
            D(fprintf(stderr, "%*c+ disjunction[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "conjunction"));
            _res = conjunction_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s disjunction[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "conjunction"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, disjunction_type, _res);
    p->level--;
    return _res;
}

// conjunction: inversion (('and' inversion))+ | inversion
static expr_ty
conjunction_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, conjunction_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // inversion (('and' inversion))+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> conjunction[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "inversion (('and' inversion))+"));
        expr_ty a;
        asdl_seq * b;
        if (
            (a = inversion_rule(p))  // inversion
            &&
            (b = _loop1_89_rule(p))  // (('and' inversion))+
        )
        {
            D(fprintf(stderr, "%*c+ conjunction[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "inversion (('and' inversion))+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_BoolOp ( And , CHECK ( _PyPegen_seq_insert_in_front ( p , a , b ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s conjunction[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "inversion (('and' inversion))+"));
    }
    { // inversion
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> conjunction[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "inversion"));
        expr_ty inversion_var;
        if (
            (inversion_var = inversion_rule(p))  // inversion
        )
        {
            D(fprintf(stderr, "%*c+ conjunction[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "inversion"));
            _res = inversion_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s conjunction[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "inversion"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, conjunction_type, _res);
    p->level--;
    return _res;
}

// inversion: 'not' inversion | comparison
static expr_ty
inversion_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, inversion_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'not' inversion
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> inversion[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'not' inversion"));
        Token * _keyword;
        expr_ty a;
        if (
            (_keyword = _PyPegen_expect_token(p, 526))  // token='not'
            &&
            (a = inversion_rule(p))  // inversion
        )
        {
            D(fprintf(stderr, "%*c+ inversion[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'not' inversion"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_UnaryOp ( Not , a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s inversion[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'not' inversion"));
    }
    { // comparison
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> inversion[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "comparison"));
        expr_ty comparison_var;
        if (
            (comparison_var = comparison_rule(p))  // comparison
        )
        {
            D(fprintf(stderr, "%*c+ inversion[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "comparison"));
            _res = comparison_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s inversion[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "comparison"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, inversion_type, _res);
    p->level--;
    return _res;
}

// comparison: bitwise_or compare_op_bitwise_or_pair+ | bitwise_or
static expr_ty
comparison_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // bitwise_or compare_op_bitwise_or_pair+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> comparison[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "bitwise_or compare_op_bitwise_or_pair+"));
        expr_ty a;
        asdl_seq * b;
        if (
            (a = bitwise_or_rule(p))  // bitwise_or
            &&
            (b = _loop1_90_rule(p))  // compare_op_bitwise_or_pair+
        )
        {
            D(fprintf(stderr, "%*c+ comparison[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "bitwise_or compare_op_bitwise_or_pair+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Compare ( a , CHECK ( _PyPegen_get_cmpops ( p , b ) ) , CHECK ( _PyPegen_get_exprs ( p , b ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s comparison[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "bitwise_or compare_op_bitwise_or_pair+"));
    }
    { // bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> comparison[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "bitwise_or"));
        expr_ty bitwise_or_var;
        if (
            (bitwise_or_var = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ comparison[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "bitwise_or"));
            _res = bitwise_or_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s comparison[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "bitwise_or"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// compare_op_bitwise_or_pair:
//     | eq_bitwise_or
//     | noteq_bitwise_or
//     | lte_bitwise_or
//     | lt_bitwise_or
//     | gte_bitwise_or
//     | gt_bitwise_or
//     | notin_bitwise_or
//     | in_bitwise_or
//     | isnot_bitwise_or
//     | is_bitwise_or
static CmpopExprPair*
compare_op_bitwise_or_pair_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // eq_bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_bitwise_or_pair[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "eq_bitwise_or"));
        CmpopExprPair* eq_bitwise_or_var;
        if (
            (eq_bitwise_or_var = eq_bitwise_or_rule(p))  // eq_bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_bitwise_or_pair[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "eq_bitwise_or"));
            _res = eq_bitwise_or_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_bitwise_or_pair[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "eq_bitwise_or"));
    }
    { // noteq_bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_bitwise_or_pair[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "noteq_bitwise_or"));
        CmpopExprPair* noteq_bitwise_or_var;
        if (
            (noteq_bitwise_or_var = noteq_bitwise_or_rule(p))  // noteq_bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_bitwise_or_pair[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "noteq_bitwise_or"));
            _res = noteq_bitwise_or_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_bitwise_or_pair[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "noteq_bitwise_or"));
    }
    { // lte_bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_bitwise_or_pair[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lte_bitwise_or"));
        CmpopExprPair* lte_bitwise_or_var;
        if (
            (lte_bitwise_or_var = lte_bitwise_or_rule(p))  // lte_bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_bitwise_or_pair[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lte_bitwise_or"));
            _res = lte_bitwise_or_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_bitwise_or_pair[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lte_bitwise_or"));
    }
    { // lt_bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_bitwise_or_pair[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lt_bitwise_or"));
        CmpopExprPair* lt_bitwise_or_var;
        if (
            (lt_bitwise_or_var = lt_bitwise_or_rule(p))  // lt_bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_bitwise_or_pair[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lt_bitwise_or"));
            _res = lt_bitwise_or_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_bitwise_or_pair[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lt_bitwise_or"));
    }
    { // gte_bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_bitwise_or_pair[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "gte_bitwise_or"));
        CmpopExprPair* gte_bitwise_or_var;
        if (
            (gte_bitwise_or_var = gte_bitwise_or_rule(p))  // gte_bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_bitwise_or_pair[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "gte_bitwise_or"));
            _res = gte_bitwise_or_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_bitwise_or_pair[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "gte_bitwise_or"));
    }
    { // gt_bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_bitwise_or_pair[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "gt_bitwise_or"));
        CmpopExprPair* gt_bitwise_or_var;
        if (
            (gt_bitwise_or_var = gt_bitwise_or_rule(p))  // gt_bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_bitwise_or_pair[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "gt_bitwise_or"));
            _res = gt_bitwise_or_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_bitwise_or_pair[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "gt_bitwise_or"));
    }
    { // notin_bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_bitwise_or_pair[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "notin_bitwise_or"));
        CmpopExprPair* notin_bitwise_or_var;
        if (
            (notin_bitwise_or_var = notin_bitwise_or_rule(p))  // notin_bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_bitwise_or_pair[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "notin_bitwise_or"));
            _res = notin_bitwise_or_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_bitwise_or_pair[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "notin_bitwise_or"));
    }
    { // in_bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_bitwise_or_pair[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "in_bitwise_or"));
        CmpopExprPair* in_bitwise_or_var;
        if (
            (in_bitwise_or_var = in_bitwise_or_rule(p))  // in_bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_bitwise_or_pair[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "in_bitwise_or"));
            _res = in_bitwise_or_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_bitwise_or_pair[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "in_bitwise_or"));
    }
    { // isnot_bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_bitwise_or_pair[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "isnot_bitwise_or"));
        CmpopExprPair* isnot_bitwise_or_var;
        if (
            (isnot_bitwise_or_var = isnot_bitwise_or_rule(p))  // isnot_bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_bitwise_or_pair[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "isnot_bitwise_or"));
            _res = isnot_bitwise_or_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_bitwise_or_pair[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "isnot_bitwise_or"));
    }
    { // is_bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_bitwise_or_pair[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "is_bitwise_or"));
        CmpopExprPair* is_bitwise_or_var;
        if (
            (is_bitwise_or_var = is_bitwise_or_rule(p))  // is_bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_bitwise_or_pair[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "is_bitwise_or"));
            _res = is_bitwise_or_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_bitwise_or_pair[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "is_bitwise_or"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// eq_bitwise_or: '==' bitwise_or
static CmpopExprPair*
eq_bitwise_or_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // '==' bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> eq_bitwise_or[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'==' bitwise_or"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 27))  // token='=='
            &&
            (a = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ eq_bitwise_or[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'==' bitwise_or"));
            _res = _PyPegen_cmpop_expr_pair ( p , Eq , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s eq_bitwise_or[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'==' bitwise_or"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// noteq_bitwise_or: ('!=') bitwise_or
static CmpopExprPair*
noteq_bitwise_or_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // ('!=') bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> noteq_bitwise_or[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "('!=') bitwise_or"));
        void *_tmp_91_var;
        expr_ty a;
        if (
            (_tmp_91_var = _tmp_91_rule(p))  // '!='
            &&
            (a = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ noteq_bitwise_or[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "('!=') bitwise_or"));
            _res = _PyPegen_cmpop_expr_pair ( p , NotEq , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s noteq_bitwise_or[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "('!=') bitwise_or"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lte_bitwise_or: '<=' bitwise_or
static CmpopExprPair*
lte_bitwise_or_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // '<=' bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lte_bitwise_or[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'<=' bitwise_or"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 29))  // token='<='
            &&
            (a = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ lte_bitwise_or[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'<=' bitwise_or"));
            _res = _PyPegen_cmpop_expr_pair ( p , LtE , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lte_bitwise_or[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'<=' bitwise_or"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lt_bitwise_or: '<' bitwise_or
static CmpopExprPair*
lt_bitwise_or_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // '<' bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lt_bitwise_or[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'<' bitwise_or"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 20))  // token='<'
            &&
            (a = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ lt_bitwise_or[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'<' bitwise_or"));
            _res = _PyPegen_cmpop_expr_pair ( p , Lt , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lt_bitwise_or[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'<' bitwise_or"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// gte_bitwise_or: '>=' bitwise_or
static CmpopExprPair*
gte_bitwise_or_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // '>=' bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> gte_bitwise_or[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'>=' bitwise_or"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 30))  // token='>='
            &&
            (a = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ gte_bitwise_or[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'>=' bitwise_or"));
            _res = _PyPegen_cmpop_expr_pair ( p , GtE , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s gte_bitwise_or[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'>=' bitwise_or"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// gt_bitwise_or: '>' bitwise_or
static CmpopExprPair*
gt_bitwise_or_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // '>' bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> gt_bitwise_or[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'>' bitwise_or"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 21))  // token='>'
            &&
            (a = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ gt_bitwise_or[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'>' bitwise_or"));
            _res = _PyPegen_cmpop_expr_pair ( p , Gt , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s gt_bitwise_or[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'>' bitwise_or"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// notin_bitwise_or: 'not' 'in' bitwise_or
static CmpopExprPair*
notin_bitwise_or_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // 'not' 'in' bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> notin_bitwise_or[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'not' 'in' bitwise_or"));
        Token * _keyword;
        Token * _keyword_1;
        expr_ty a;
        if (
            (_keyword = _PyPegen_expect_token(p, 526))  // token='not'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 518))  // token='in'
            &&
            (a = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ notin_bitwise_or[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'not' 'in' bitwise_or"));
            _res = _PyPegen_cmpop_expr_pair ( p , NotIn , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s notin_bitwise_or[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'not' 'in' bitwise_or"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// in_bitwise_or: 'in' bitwise_or
static CmpopExprPair*
in_bitwise_or_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // 'in' bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> in_bitwise_or[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'in' bitwise_or"));
        Token * _keyword;
        expr_ty a;
        if (
            (_keyword = _PyPegen_expect_token(p, 518))  // token='in'
            &&
            (a = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ in_bitwise_or[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'in' bitwise_or"));
            _res = _PyPegen_cmpop_expr_pair ( p , In , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s in_bitwise_or[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'in' bitwise_or"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// isnot_bitwise_or: 'is' 'not' bitwise_or
static CmpopExprPair*
isnot_bitwise_or_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // 'is' 'not' bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> isnot_bitwise_or[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'is' 'not' bitwise_or"));
        Token * _keyword;
        Token * _keyword_1;
        expr_ty a;
        if (
            (_keyword = _PyPegen_expect_token(p, 527))  // token='is'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 526))  // token='not'
            &&
            (a = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ isnot_bitwise_or[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'is' 'not' bitwise_or"));
            _res = _PyPegen_cmpop_expr_pair ( p , IsNot , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s isnot_bitwise_or[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'is' 'not' bitwise_or"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// is_bitwise_or: 'is' bitwise_or
static CmpopExprPair*
is_bitwise_or_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // 'is' bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> is_bitwise_or[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'is' bitwise_or"));
        Token * _keyword;
        expr_ty a;
        if (
            (_keyword = _PyPegen_expect_token(p, 527))  // token='is'
            &&
            (a = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ is_bitwise_or[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'is' bitwise_or"));
            _res = _PyPegen_cmpop_expr_pair ( p , Is , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s is_bitwise_or[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'is' bitwise_or"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor
static expr_ty bitwise_or_raw(Parser *);
static expr_ty
bitwise_or_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, bitwise_or_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_1 = _PyPegen_update_memo(p, _mark, bitwise_or_type, _res);
        if (tmpvar_1) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = bitwise_or_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
bitwise_or_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // bitwise_or '|' bitwise_xor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> bitwise_or[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "bitwise_or '|' bitwise_xor"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = bitwise_or_rule(p))  // bitwise_or
            &&
            (_literal = _PyPegen_expect_token(p, 18))  // token='|'
            &&
            (b = bitwise_xor_rule(p))  // bitwise_xor
        )
        {
            D(fprintf(stderr, "%*c+ bitwise_or[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "bitwise_or '|' bitwise_xor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_BinOp ( a , BitOr , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s bitwise_or[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "bitwise_or '|' bitwise_xor"));
    }
    { // bitwise_xor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> bitwise_or[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "bitwise_xor"));
        expr_ty bitwise_xor_var;
        if (
            (bitwise_xor_var = bitwise_xor_rule(p))  // bitwise_xor
        )
        {
            D(fprintf(stderr, "%*c+ bitwise_or[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "bitwise_xor"));
            _res = bitwise_xor_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s bitwise_or[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "bitwise_xor"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and
static expr_ty bitwise_xor_raw(Parser *);
static expr_ty
bitwise_xor_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, bitwise_xor_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_2 = _PyPegen_update_memo(p, _mark, bitwise_xor_type, _res);
        if (tmpvar_2) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = bitwise_xor_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
bitwise_xor_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // bitwise_xor '^' bitwise_and
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> bitwise_xor[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "bitwise_xor '^' bitwise_and"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = bitwise_xor_rule(p))  // bitwise_xor
            &&
            (_literal = _PyPegen_expect_token(p, 32))  // token='^'
            &&
            (b = bitwise_and_rule(p))  // bitwise_and
        )
        {
            D(fprintf(stderr, "%*c+ bitwise_xor[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "bitwise_xor '^' bitwise_and"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_BinOp ( a , BitXor , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s bitwise_xor[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "bitwise_xor '^' bitwise_and"));
    }
    { // bitwise_and
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> bitwise_xor[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "bitwise_and"));
        expr_ty bitwise_and_var;
        if (
            (bitwise_and_var = bitwise_and_rule(p))  // bitwise_and
        )
        {
            D(fprintf(stderr, "%*c+ bitwise_xor[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "bitwise_and"));
            _res = bitwise_and_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s bitwise_xor[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "bitwise_and"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// bitwise_and: bitwise_and '&' shift_expr | shift_expr
static expr_ty bitwise_and_raw(Parser *);
static expr_ty
bitwise_and_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, bitwise_and_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_3 = _PyPegen_update_memo(p, _mark, bitwise_and_type, _res);
        if (tmpvar_3) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = bitwise_and_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
bitwise_and_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // bitwise_and '&' shift_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> bitwise_and[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "bitwise_and '&' shift_expr"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = bitwise_and_rule(p))  // bitwise_and
            &&
            (_literal = _PyPegen_expect_token(p, 19))  // token='&'
            &&
            (b = shift_expr_rule(p))  // shift_expr
        )
        {
            D(fprintf(stderr, "%*c+ bitwise_and[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "bitwise_and '&' shift_expr"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_BinOp ( a , BitAnd , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s bitwise_and[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "bitwise_and '&' shift_expr"));
    }
    { // shift_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> bitwise_and[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "shift_expr"));
        expr_ty shift_expr_var;
        if (
            (shift_expr_var = shift_expr_rule(p))  // shift_expr
        )
        {
            D(fprintf(stderr, "%*c+ bitwise_and[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "shift_expr"));
            _res = shift_expr_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s bitwise_and[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "shift_expr"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum
static expr_ty shift_expr_raw(Parser *);
static expr_ty
shift_expr_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, shift_expr_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_4 = _PyPegen_update_memo(p, _mark, shift_expr_type, _res);
        if (tmpvar_4) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = shift_expr_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
shift_expr_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // shift_expr '<<' sum
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> shift_expr[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "shift_expr '<<' sum"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = shift_expr_rule(p))  // shift_expr
            &&
            (_literal = _PyPegen_expect_token(p, 33))  // token='<<'
            &&
            (b = sum_rule(p))  // sum
        )
        {
            D(fprintf(stderr, "%*c+ shift_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "shift_expr '<<' sum"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_BinOp ( a , LShift , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s shift_expr[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "shift_expr '<<' sum"));
    }
    { // shift_expr '>>' sum
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> shift_expr[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "shift_expr '>>' sum"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = shift_expr_rule(p))  // shift_expr
            &&
            (_literal = _PyPegen_expect_token(p, 34))  // token='>>'
            &&
            (b = sum_rule(p))  // sum
        )
        {
            D(fprintf(stderr, "%*c+ shift_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "shift_expr '>>' sum"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_BinOp ( a , RShift , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s shift_expr[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "shift_expr '>>' sum"));
    }
    { // sum
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> shift_expr[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "sum"));
        expr_ty sum_var;
        if (
            (sum_var = sum_rule(p))  // sum
        )
        {
            D(fprintf(stderr, "%*c+ shift_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "sum"));
            _res = sum_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s shift_expr[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "sum"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// sum: sum '+' term | sum '-' term | term
static expr_ty sum_raw(Parser *);
static expr_ty
sum_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, sum_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_5 = _PyPegen_update_memo(p, _mark, sum_type, _res);
        if (tmpvar_5) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = sum_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
sum_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // sum '+' term
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> sum[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "sum '+' term"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = sum_rule(p))  // sum
            &&
            (_literal = _PyPegen_expect_token(p, 14))  // token='+'
            &&
            (b = term_rule(p))  // term
        )
        {
            D(fprintf(stderr, "%*c+ sum[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "sum '+' term"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_BinOp ( a , Add , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sum[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "sum '+' term"));
    }
    { // sum '-' term
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> sum[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "sum '-' term"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = sum_rule(p))  // sum
            &&
            (_literal = _PyPegen_expect_token(p, 15))  // token='-'
            &&
            (b = term_rule(p))  // term
        )
        {
            D(fprintf(stderr, "%*c+ sum[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "sum '-' term"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_BinOp ( a , Sub , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sum[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "sum '-' term"));
    }
    { // term
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> sum[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "term"));
        expr_ty term_var;
        if (
            (term_var = term_rule(p))  // term
        )
        {
            D(fprintf(stderr, "%*c+ sum[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "term"));
            _res = term_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sum[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "term"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// term:
//     | term '*' factor
//     | term '/' factor
//     | term '//' factor
//     | term '%' factor
//     | term '@' factor
//     | factor
static expr_ty term_raw(Parser *);
static expr_ty
term_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, term_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_6 = _PyPegen_update_memo(p, _mark, term_type, _res);
        if (tmpvar_6) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = term_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
term_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // term '*' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> term[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "term '*' factor"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = term_rule(p))  // term
            &&
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (b = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ term[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "term '*' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_BinOp ( a , Mult , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "term '*' factor"));
    }
    { // term '/' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> term[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "term '/' factor"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = term_rule(p))  // term
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (b = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ term[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "term '/' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_BinOp ( a , Div , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "term '/' factor"));
    }
    { // term '//' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> term[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "term '//' factor"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = term_rule(p))  // term
            &&
            (_literal = _PyPegen_expect_token(p, 47))  // token='//'
            &&
            (b = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ term[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "term '//' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_BinOp ( a , FloorDiv , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "term '//' factor"));
    }
    { // term '%' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> term[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "term '%' factor"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = term_rule(p))  // term
            &&
            (_literal = _PyPegen_expect_token(p, 24))  // token='%'
            &&
            (b = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ term[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "term '%' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_BinOp ( a , Mod , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "term '%' factor"));
    }
    { // term '@' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> term[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "term '@' factor"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = term_rule(p))  // term
            &&
            (_literal = _PyPegen_expect_token(p, 49))  // token='@'
            &&
            (b = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ term[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "term '@' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( 5 , "The '@' operator is" , _Py_BinOp ( a , MatMult , b , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "term '@' factor"));
    }
    { // factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> term[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "factor"));
        expr_ty factor_var;
        if (
            (factor_var = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ term[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "factor"));
            _res = factor_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "factor"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// factor: '+' factor | '-' factor | '~' factor | power
static expr_ty
factor_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, factor_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '+' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> factor[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'+' factor"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 14))  // token='+'
            &&
            (a = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ factor[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'+' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_UnaryOp ( UAdd , a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s factor[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'+' factor"));
    }
    { // '-' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> factor[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'-' factor"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 15))  // token='-'
            &&
            (a = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ factor[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'-' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_UnaryOp ( USub , a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s factor[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'-' factor"));
    }
    { // '~' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> factor[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'~' factor"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 31))  // token='~'
            &&
            (a = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ factor[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'~' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_UnaryOp ( Invert , a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s factor[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'~' factor"));
    }
    { // power
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> factor[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "power"));
        expr_ty power_var;
        if (
            (power_var = power_rule(p))  // power
        )
        {
            D(fprintf(stderr, "%*c+ factor[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "power"));
            _res = power_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s factor[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "power"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, factor_type, _res);
    p->level--;
    return _res;
}

// power: await_primary '**' factor | await_primary
static expr_ty
power_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // await_primary '**' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> power[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "await_primary '**' factor"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = await_primary_rule(p))  // await_primary
            &&
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (b = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ power[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "await_primary '**' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_BinOp ( a , Pow , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s power[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "await_primary '**' factor"));
    }
    { // await_primary
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> power[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "await_primary"));
        expr_ty await_primary_var;
        if (
            (await_primary_var = await_primary_rule(p))  // await_primary
        )
        {
            D(fprintf(stderr, "%*c+ power[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "await_primary"));
            _res = await_primary_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s power[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "await_primary"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// await_primary: AWAIT primary | primary
static expr_ty
await_primary_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, await_primary_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // AWAIT primary
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> await_primary[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "AWAIT primary"));
        expr_ty a;
        Token * await_var;
        if (
            (await_var = _PyPegen_expect_token(p, AWAIT))  // token='AWAIT'
            &&
            (a = primary_rule(p))  // primary
        )
        {
            D(fprintf(stderr, "%*c+ await_primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "AWAIT primary"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( 5 , "Await expressions are" , _Py_Await ( a , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s await_primary[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "AWAIT primary"));
    }
    { // primary
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> await_primary[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "primary"));
        expr_ty primary_var;
        if (
            (primary_var = primary_rule(p))  // primary
        )
        {
            D(fprintf(stderr, "%*c+ await_primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "primary"));
            _res = primary_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s await_primary[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "primary"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, await_primary_type, _res);
    p->level--;
    return _res;
}

// Left-recursive
// primary:
//     | invalid_primary
//     | primary '.' NAME
//     | primary genexp
//     | primary '(' arguments? ')'
//     | primary '[' slices ']'
//     | atom
static expr_ty primary_raw(Parser *);
static expr_ty
primary_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, primary_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_7 = _PyPegen_update_memo(p, _mark, primary_type, _res);
        if (tmpvar_7) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = primary_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
primary_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_primary
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> primary[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_primary"));
        void *invalid_primary_var;
        if (
            (invalid_primary_var = invalid_primary_rule(p))  // invalid_primary
        )
        {
            D(fprintf(stderr, "%*c+ primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_primary"));
            _res = invalid_primary_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s primary[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_primary"));
    }
    { // primary '.' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> primary[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "primary '.' NAME"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = primary_rule(p))  // primary
            &&
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
            &&
            (b = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "primary '.' NAME"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Attribute ( a , b -> v . Name . id , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s primary[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "primary '.' NAME"));
    }
    { // primary genexp
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> primary[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "primary genexp"));
        expr_ty a;
        expr_ty b;
        if (
            (a = primary_rule(p))  // primary
            &&
            (b = genexp_rule(p))  // genexp
        )
        {
            D(fprintf(stderr, "%*c+ primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "primary genexp"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Call ( a , CHECK ( _PyPegen_singleton_seq ( p , b ) ) , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s primary[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "primary genexp"));
    }
    { // primary '(' arguments? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> primary[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "primary '(' arguments? ')'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        void *b;
        if (
            (a = primary_rule(p))  // primary
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (b = arguments_rule(p), !p->error_indicator)  // arguments?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "primary '(' arguments? ')'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Call ( a , ( b ) ? ( ( expr_ty ) b ) -> v . Call . args : NULL , ( b ) ? ( ( expr_ty ) b ) -> v . Call . keywords : NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s primary[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "primary '(' arguments? ')'"));
    }
    { // primary '[' slices ']'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> primary[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "primary '[' slices ']'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        expr_ty b;
        if (
            (a = primary_rule(p))  // primary
            &&
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (b = slices_rule(p))  // slices
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
        )
        {
            D(fprintf(stderr, "%*c+ primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "primary '[' slices ']'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Subscript ( a , b , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s primary[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "primary '[' slices ']'"));
    }
    { // atom
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> primary[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "atom"));
        expr_ty atom_var;
        if (
            (atom_var = atom_rule(p))  // atom
        )
        {
            D(fprintf(stderr, "%*c+ primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "atom"));
            _res = atom_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s primary[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "atom"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// slices: slice !',' | ','.slice+ ','?
static expr_ty
slices_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // slice !','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> slices[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "slice !','"));
        expr_ty a;
        if (
            (a = slice_rule(p))  // slice
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 12)  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ slices[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "slice !','"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s slices[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "slice !','"));
    }
    { // ','.slice+ ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> slices[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.slice+ ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_seq * a;
        if (
            (a = _gather_92_rule(p))  // ','.slice+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ slices[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.slice+ ','?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Tuple ( a , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s slices[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.slice+ ','?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// slice: expression? ':' expression? [':' expression?] | expression
static expr_ty
slice_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // expression? ':' expression? [':' expression?]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> slice[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression? ':' expression? [':' expression?]"));
        Token * _literal;
        void *a;
        void *b;
        void *c;
        if (
            (a = expression_rule(p), !p->error_indicator)  // expression?
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = expression_rule(p), !p->error_indicator)  // expression?
            &&
            (c = _tmp_94_rule(p), !p->error_indicator)  // [':' expression?]
        )
        {
            D(fprintf(stderr, "%*c+ slice[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression? ':' expression? [':' expression?]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Slice ( a , b , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s slice[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression? ':' expression? [':' expression?]"));
    }
    { // expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> slice[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression"));
        expr_ty a;
        if (
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ slice[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s slice[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// atom:
//     | NAME
//     | 'True'
//     | 'False'
//     | 'None'
//     | '__peg_parser__'
//     | &STRING strings
//     | NUMBER
//     | &'(' (tuple | group | genexp)
//     | &'[' (list | listcomp)
//     | &'{' (dict | set | dictcomp | setcomp)
//     | '...'
static expr_ty
atom_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NAME"));
        expr_ty name_var;
        if (
            (name_var = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME"));
            _res = name_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NAME"));
    }
    { // 'True'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'True'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 528))  // token='True'
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'True'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Constant ( Py_True , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'True'"));
    }
    { // 'False'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'False'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 529))  // token='False'
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'False'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Constant ( Py_False , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'False'"));
    }
    { // 'None'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'None'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 530))  // token='None'
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'None'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Constant ( Py_None , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'None'"));
    }
    { // '__peg_parser__'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'__peg_parser__'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 531))  // token='__peg_parser__'
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'__peg_parser__'"));
            _res = RAISE_SYNTAX_ERROR ( "You found it!" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'__peg_parser__'"));
    }
    { // &STRING strings
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&STRING strings"));
        expr_ty strings_var;
        if (
            _PyPegen_lookahead(1, _PyPegen_string_token, p)
            &&
            (strings_var = strings_rule(p))  // strings
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&STRING strings"));
            _res = strings_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&STRING strings"));
    }
    { // NUMBER
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NUMBER"));
        expr_ty number_var;
        if (
            (number_var = _PyPegen_number_token(p))  // NUMBER
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NUMBER"));
            _res = number_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NUMBER"));
    }
    { // &'(' (tuple | group | genexp)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'(' (tuple | group | genexp)"));
        void *_tmp_95_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 7)  // token='('
            &&
            (_tmp_95_var = _tmp_95_rule(p))  // tuple | group | genexp
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'(' (tuple | group | genexp)"));
            _res = _tmp_95_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'(' (tuple | group | genexp)"));
    }
    { // &'[' (list | listcomp)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'[' (list | listcomp)"));
        void *_tmp_96_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 9)  // token='['
            &&
            (_tmp_96_var = _tmp_96_rule(p))  // list | listcomp
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'[' (list | listcomp)"));
            _res = _tmp_96_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'[' (list | listcomp)"));
    }
    { // &'{' (dict | set | dictcomp | setcomp)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'{' (dict | set | dictcomp | setcomp)"));
        void *_tmp_97_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 25)  // token='{'
            &&
            (_tmp_97_var = _tmp_97_rule(p))  // dict | set | dictcomp | setcomp
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'{' (dict | set | dictcomp | setcomp)"));
            _res = _tmp_97_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'{' (dict | set | dictcomp | setcomp)"));
    }
    { // '...'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'...'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 52))  // token='...'
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'...'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Constant ( Py_Ellipsis , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'...'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// strings: STRING+
static expr_ty
strings_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, strings_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    { // STRING+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> strings[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "STRING+"));
        asdl_seq * a;
        if (
            (a = _loop1_98_rule(p))  // STRING+
        )
        {
            D(fprintf(stderr, "%*c+ strings[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "STRING+"));
            _res = _PyPegen_concatenate_strings ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s strings[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "STRING+"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, strings_type, _res);
    p->level--;
    return _res;
}

// list: '[' star_named_expressions? ']'
static expr_ty
list_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '[' star_named_expressions? ']'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> list[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'[' star_named_expressions? ']'"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (a = star_named_expressions_rule(p), !p->error_indicator)  // star_named_expressions?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
        )
        {
            D(fprintf(stderr, "%*c+ list[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'[' star_named_expressions? ']'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_List ( a , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s list[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'[' star_named_expressions? ']'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// listcomp: '[' named_expression ~ for_if_clauses ']' | invalid_comprehension
static expr_ty
listcomp_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '[' named_expression ~ for_if_clauses ']'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> listcomp[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'[' named_expression ~ for_if_clauses ']'"));
        int _cut_var = 0;
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        asdl_seq* b;
        if (
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (_cut_var = 1)
            &&
            (b = for_if_clauses_rule(p))  // for_if_clauses
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
        )
        {
            D(fprintf(stderr, "%*c+ listcomp[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'[' named_expression ~ for_if_clauses ']'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_ListComp ( a , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s listcomp[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'[' named_expression ~ for_if_clauses ']'"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    if (p->call_invalid_rules) { // invalid_comprehension
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> listcomp[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_comprehension"));
        void *invalid_comprehension_var;
        if (
            (invalid_comprehension_var = invalid_comprehension_rule(p))  // invalid_comprehension
        )
        {
            D(fprintf(stderr, "%*c+ listcomp[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_comprehension"));
            _res = invalid_comprehension_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s listcomp[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_comprehension"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// tuple: '(' [star_named_expression ',' star_named_expressions?] ')'
static expr_ty
tuple_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '(' [star_named_expression ',' star_named_expressions?] ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> tuple[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'(' [star_named_expression ',' star_named_expressions?] ')'"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = _tmp_99_rule(p), !p->error_indicator)  // [star_named_expression ',' star_named_expressions?]
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ tuple[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' [star_named_expression ',' star_named_expressions?] ')'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Tuple ( a , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s tuple[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'(' [star_named_expression ',' star_named_expressions?] ')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// group: '(' (yield_expr | named_expression) ')' | invalid_group
static expr_ty
group_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // '(' (yield_expr | named_expression) ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> group[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'(' (yield_expr | named_expression) ')'"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = _tmp_100_rule(p))  // yield_expr | named_expression
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ group[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' (yield_expr | named_expression) ')'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s group[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'(' (yield_expr | named_expression) ')'"));
    }
    if (p->call_invalid_rules) { // invalid_group
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> group[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_group"));
        void *invalid_group_var;
        if (
            (invalid_group_var = invalid_group_rule(p))  // invalid_group
        )
        {
            D(fprintf(stderr, "%*c+ group[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_group"));
            _res = invalid_group_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s group[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_group"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// genexp: '(' named_expression ~ for_if_clauses ')' | invalid_comprehension
static expr_ty
genexp_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '(' named_expression ~ for_if_clauses ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> genexp[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'(' named_expression ~ for_if_clauses ')'"));
        int _cut_var = 0;
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        asdl_seq* b;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (_cut_var = 1)
            &&
            (b = for_if_clauses_rule(p))  // for_if_clauses
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ genexp[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' named_expression ~ for_if_clauses ')'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_GeneratorExp ( a , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s genexp[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'(' named_expression ~ for_if_clauses ')'"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    if (p->call_invalid_rules) { // invalid_comprehension
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> genexp[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_comprehension"));
        void *invalid_comprehension_var;
        if (
            (invalid_comprehension_var = invalid_comprehension_rule(p))  // invalid_comprehension
        )
        {
            D(fprintf(stderr, "%*c+ genexp[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_comprehension"));
            _res = invalid_comprehension_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s genexp[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_comprehension"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// set: '{' star_named_expressions '}'
static expr_ty
set_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '{' star_named_expressions '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> set[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'{' star_named_expressions '}'"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq* a;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (a = star_named_expressions_rule(p))  // star_named_expressions
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ set[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'{' star_named_expressions '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Set ( a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s set[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'{' star_named_expressions '}'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// setcomp: '{' named_expression ~ for_if_clauses '}' | invalid_comprehension
static expr_ty
setcomp_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '{' named_expression ~ for_if_clauses '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> setcomp[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'{' named_expression ~ for_if_clauses '}'"));
        int _cut_var = 0;
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        asdl_seq* b;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (_cut_var = 1)
            &&
            (b = for_if_clauses_rule(p))  // for_if_clauses
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ setcomp[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'{' named_expression ~ for_if_clauses '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_SetComp ( a , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s setcomp[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'{' named_expression ~ for_if_clauses '}'"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    if (p->call_invalid_rules) { // invalid_comprehension
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> setcomp[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_comprehension"));
        void *invalid_comprehension_var;
        if (
            (invalid_comprehension_var = invalid_comprehension_rule(p))  // invalid_comprehension
        )
        {
            D(fprintf(stderr, "%*c+ setcomp[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_comprehension"));
            _res = invalid_comprehension_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s setcomp[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_comprehension"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// dict: '{' double_starred_kvpairs? '}'
static expr_ty
dict_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '{' double_starred_kvpairs? '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dict[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'{' double_starred_kvpairs? '}'"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (a = double_starred_kvpairs_rule(p), !p->error_indicator)  // double_starred_kvpairs?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ dict[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'{' double_starred_kvpairs? '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Dict ( CHECK ( _PyPegen_get_keys ( p , a ) ) , CHECK ( _PyPegen_get_values ( p , a ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dict[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'{' double_starred_kvpairs? '}'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// dictcomp: '{' kvpair for_if_clauses '}' | invalid_dict_comprehension
static expr_ty
dictcomp_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '{' kvpair for_if_clauses '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dictcomp[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'{' kvpair for_if_clauses '}'"));
        Token * _literal;
        Token * _literal_1;
        KeyValuePair* a;
        asdl_seq* b;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (a = kvpair_rule(p))  // kvpair
            &&
            (b = for_if_clauses_rule(p))  // for_if_clauses
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ dictcomp[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'{' kvpair for_if_clauses '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_DictComp ( a -> key , a -> value , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dictcomp[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'{' kvpair for_if_clauses '}'"));
    }
    if (p->call_invalid_rules) { // invalid_dict_comprehension
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dictcomp[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_dict_comprehension"));
        void *invalid_dict_comprehension_var;
        if (
            (invalid_dict_comprehension_var = invalid_dict_comprehension_rule(p))  // invalid_dict_comprehension
        )
        {
            D(fprintf(stderr, "%*c+ dictcomp[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_dict_comprehension"));
            _res = invalid_dict_comprehension_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dictcomp[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_dict_comprehension"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// double_starred_kvpairs: ','.double_starred_kvpair+ ','?
static asdl_seq*
double_starred_kvpairs_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.double_starred_kvpair+ ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> double_starred_kvpairs[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.double_starred_kvpair+ ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_seq * a;
        if (
            (a = _gather_101_rule(p))  // ','.double_starred_kvpair+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ double_starred_kvpairs[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.double_starred_kvpair+ ','?"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s double_starred_kvpairs[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.double_starred_kvpair+ ','?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// double_starred_kvpair: '**' bitwise_or | kvpair
static KeyValuePair*
double_starred_kvpair_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    KeyValuePair* _res = NULL;
    int _mark = p->mark;
    { // '**' bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> double_starred_kvpair[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'**' bitwise_or"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (a = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ double_starred_kvpair[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'**' bitwise_or"));
            _res = _PyPegen_key_value_pair ( p , NULL , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s double_starred_kvpair[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'**' bitwise_or"));
    }
    { // kvpair
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> double_starred_kvpair[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "kvpair"));
        KeyValuePair* kvpair_var;
        if (
            (kvpair_var = kvpair_rule(p))  // kvpair
        )
        {
            D(fprintf(stderr, "%*c+ double_starred_kvpair[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "kvpair"));
            _res = kvpair_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s double_starred_kvpair[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "kvpair"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// kvpair: expression ':' expression
static KeyValuePair*
kvpair_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    KeyValuePair* _res = NULL;
    int _mark = p->mark;
    { // expression ':' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kvpair[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression ':' expression"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = expression_rule(p))  // expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ kvpair[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression ':' expression"));
            _res = _PyPegen_key_value_pair ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kvpair[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression ':' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// for_if_clauses: for_if_clause+
static asdl_seq*
for_if_clauses_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // for_if_clause+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_if_clauses[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "for_if_clause+"));
        asdl_seq * _loop1_103_var;
        if (
            (_loop1_103_var = _loop1_103_rule(p))  // for_if_clause+
        )
        {
            D(fprintf(stderr, "%*c+ for_if_clauses[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "for_if_clause+"));
            _res = _loop1_103_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_if_clauses[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "for_if_clause+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// for_if_clause:
//     | ASYNC 'for' star_targets 'in' ~ disjunction (('if' disjunction))*
//     | 'for' star_targets 'in' ~ disjunction (('if' disjunction))*
//     | invalid_for_target
static comprehension_ty
for_if_clause_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    comprehension_ty _res = NULL;
    int _mark = p->mark;
    { // ASYNC 'for' star_targets 'in' ~ disjunction (('if' disjunction))*
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_if_clause[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "ASYNC 'for' star_targets 'in' ~ disjunction (('if' disjunction))*"));
        int _cut_var = 0;
        Token * _keyword;
        Token * _keyword_1;
        expr_ty a;
        Token * async_var;
        expr_ty b;
        asdl_seq * c;
        if (
            (async_var = _PyPegen_expect_token(p, ASYNC))  // token='ASYNC'
            &&
            (_keyword = _PyPegen_expect_token(p, 517))  // token='for'
            &&
            (a = star_targets_rule(p))  // star_targets
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 518))  // token='in'
            &&
            (_cut_var = 1)
            &&
            (b = disjunction_rule(p))  // disjunction
            &&
            (c = _loop0_104_rule(p))  // (('if' disjunction))*
        )
        {
            D(fprintf(stderr, "%*c+ for_if_clause[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "ASYNC 'for' star_targets 'in' ~ disjunction (('if' disjunction))*"));
            _res = CHECK_VERSION ( 6 , "Async comprehensions are" , _Py_comprehension ( a , b , c , 1 , p -> arena ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_if_clause[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "ASYNC 'for' star_targets 'in' ~ disjunction (('if' disjunction))*"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    { // 'for' star_targets 'in' ~ disjunction (('if' disjunction))*
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_if_clause[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'for' star_targets 'in' ~ disjunction (('if' disjunction))*"));
        int _cut_var = 0;
        Token * _keyword;
        Token * _keyword_1;
        expr_ty a;
        expr_ty b;
        asdl_seq * c;
        if (
            (_keyword = _PyPegen_expect_token(p, 517))  // token='for'
            &&
            (a = star_targets_rule(p))  // star_targets
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 518))  // token='in'
            &&
            (_cut_var = 1)
            &&
            (b = disjunction_rule(p))  // disjunction
            &&
            (c = _loop0_105_rule(p))  // (('if' disjunction))*
        )
        {
            D(fprintf(stderr, "%*c+ for_if_clause[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'for' star_targets 'in' ~ disjunction (('if' disjunction))*"));
            _res = _Py_comprehension ( a , b , c , 0 , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_if_clause[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'for' star_targets 'in' ~ disjunction (('if' disjunction))*"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    if (p->call_invalid_rules) { // invalid_for_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_if_clause[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_for_target"));
        void *invalid_for_target_var;
        if (
            (invalid_for_target_var = invalid_for_target_rule(p))  // invalid_for_target
        )
        {
            D(fprintf(stderr, "%*c+ for_if_clause[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_for_target"));
            _res = invalid_for_target_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_if_clause[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_for_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// yield_expr: 'yield' 'from' expression | 'yield' star_expressions?
static expr_ty
yield_expr_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'yield' 'from' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> yield_expr[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'yield' 'from' expression"));
        Token * _keyword;
        Token * _keyword_1;
        expr_ty a;
        if (
            (_keyword = _PyPegen_expect_token(p, 504))  // token='yield'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 514))  // token='from'
            &&
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ yield_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'yield' 'from' expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_YieldFrom ( a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s yield_expr[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'yield' 'from' expression"));
    }
    { // 'yield' star_expressions?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> yield_expr[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'yield' star_expressions?"));
        Token * _keyword;
        void *a;
        if (
            (_keyword = _PyPegen_expect_token(p, 504))  // token='yield'
            &&
            (a = star_expressions_rule(p), !p->error_indicator)  // star_expressions?
        )
        {
            D(fprintf(stderr, "%*c+ yield_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'yield' star_expressions?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Yield ( a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s yield_expr[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'yield' star_expressions?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// arguments: args ','? &')' | invalid_arguments
static expr_ty
arguments_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, arguments_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    { // args ','? &')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> arguments[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "args ','? &')'"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty a;
        if (
            (a = args_rule(p))  // args
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ arguments[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "args ','? &')'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s arguments[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "args ','? &')'"));
    }
    if (p->call_invalid_rules) { // invalid_arguments
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> arguments[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_arguments"));
        void *invalid_arguments_var;
        if (
            (invalid_arguments_var = invalid_arguments_rule(p))  // invalid_arguments
        )
        {
            D(fprintf(stderr, "%*c+ arguments[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_arguments"));
            _res = invalid_arguments_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s arguments[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_arguments"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, arguments_type, _res);
    p->level--;
    return _res;
}

// args: ','.(starred_expression | named_expression !'=')+ [',' kwargs] | kwargs
static expr_ty
args_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // ','.(starred_expression | named_expression !'=')+ [',' kwargs]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> args[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.(starred_expression | named_expression !'=')+ [',' kwargs]"));
        asdl_seq * a;
        void *b;
        if (
            (a = _gather_106_rule(p))  // ','.(starred_expression | named_expression !'=')+
            &&
            (b = _tmp_108_rule(p), !p->error_indicator)  // [',' kwargs]
        )
        {
            D(fprintf(stderr, "%*c+ args[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.(starred_expression | named_expression !'=')+ [',' kwargs]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_collect_call_seqs ( p , a , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s args[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.(starred_expression | named_expression !'=')+ [',' kwargs]"));
    }
    { // kwargs
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> args[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "kwargs"));
        asdl_seq* a;
        if (
            (a = kwargs_rule(p))  // kwargs
        )
        {
            D(fprintf(stderr, "%*c+ args[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "kwargs"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Call ( _PyPegen_dummy_name ( p ) , CHECK_NULL_ALLOWED ( _PyPegen_seq_extract_starred_exprs ( p , a ) ) , CHECK_NULL_ALLOWED ( _PyPegen_seq_delete_starred_exprs ( p , a ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s args[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "kwargs"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// kwargs:
//     | ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+
//     | ','.kwarg_or_starred+
//     | ','.kwarg_or_double_starred+
static asdl_seq*
kwargs_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwargs[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+"));
        Token * _literal;
        asdl_seq * a;
        asdl_seq * b;
        if (
            (a = _gather_109_rule(p))  // ','.kwarg_or_starred+
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (b = _gather_111_rule(p))  // ','.kwarg_or_double_starred+
        )
        {
            D(fprintf(stderr, "%*c+ kwargs[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+"));
            _res = _PyPegen_join_sequences ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwargs[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+"));
    }
    { // ','.kwarg_or_starred+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwargs[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.kwarg_or_starred+"));
        asdl_seq * _gather_113_var;
        if (
            (_gather_113_var = _gather_113_rule(p))  // ','.kwarg_or_starred+
        )
        {
            D(fprintf(stderr, "%*c+ kwargs[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.kwarg_or_starred+"));
            _res = _gather_113_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwargs[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.kwarg_or_starred+"));
    }
    { // ','.kwarg_or_double_starred+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwargs[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.kwarg_or_double_starred+"));
        asdl_seq * _gather_115_var;
        if (
            (_gather_115_var = _gather_115_rule(p))  // ','.kwarg_or_double_starred+
        )
        {
            D(fprintf(stderr, "%*c+ kwargs[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.kwarg_or_double_starred+"));
            _res = _gather_115_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwargs[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.kwarg_or_double_starred+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// starred_expression: '*' expression
static expr_ty
starred_expression_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '*' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> starred_expression[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*' expression"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ starred_expression[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Starred ( a , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s starred_expression[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// kwarg_or_starred: NAME '=' expression | starred_expression | invalid_kwarg
static KeywordOrStarred*
kwarg_or_starred_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    KeywordOrStarred* _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME '=' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwarg_or_starred[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NAME '=' expression"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ kwarg_or_starred[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME '=' expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_keyword_or_starred ( p , CHECK ( _Py_keyword ( a -> v . Name . id , b , EXTRA ) ) , 1 );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwarg_or_starred[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NAME '=' expression"));
    }
    { // starred_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwarg_or_starred[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "starred_expression"));
        expr_ty a;
        if (
            (a = starred_expression_rule(p))  // starred_expression
        )
        {
            D(fprintf(stderr, "%*c+ kwarg_or_starred[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "starred_expression"));
            _res = _PyPegen_keyword_or_starred ( p , a , 0 );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwarg_or_starred[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "starred_expression"));
    }
    if (p->call_invalid_rules) { // invalid_kwarg
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwarg_or_starred[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_kwarg"));
        void *invalid_kwarg_var;
        if (
            (invalid_kwarg_var = invalid_kwarg_rule(p))  // invalid_kwarg
        )
        {
            D(fprintf(stderr, "%*c+ kwarg_or_starred[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_kwarg"));
            _res = invalid_kwarg_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwarg_or_starred[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_kwarg"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// kwarg_or_double_starred: NAME '=' expression | '**' expression | invalid_kwarg
static KeywordOrStarred*
kwarg_or_double_starred_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    KeywordOrStarred* _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME '=' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwarg_or_double_starred[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NAME '=' expression"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ kwarg_or_double_starred[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME '=' expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_keyword_or_starred ( p , CHECK ( _Py_keyword ( a -> v . Name . id , b , EXTRA ) ) , 1 );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwarg_or_double_starred[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NAME '=' expression"));
    }
    { // '**' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwarg_or_double_starred[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'**' expression"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ kwarg_or_double_starred[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'**' expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_keyword_or_starred ( p , CHECK ( _Py_keyword ( NULL , a , EXTRA ) ) , 1 );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwarg_or_double_starred[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'**' expression"));
    }
    if (p->call_invalid_rules) { // invalid_kwarg
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwarg_or_double_starred[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_kwarg"));
        void *invalid_kwarg_var;
        if (
            (invalid_kwarg_var = invalid_kwarg_rule(p))  // invalid_kwarg
        )
        {
            D(fprintf(stderr, "%*c+ kwarg_or_double_starred[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_kwarg"));
            _res = invalid_kwarg_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwarg_or_double_starred[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_kwarg"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_targets: star_target !',' | star_target ((',' star_target))* ','?
static expr_ty
star_targets_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // star_target !','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_targets[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_target !','"));
        expr_ty a;
        if (
            (a = star_target_rule(p))  // star_target
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 12)  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ star_targets[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_target !','"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_targets[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_target !','"));
    }
    { // star_target ((',' star_target))* ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_targets[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_target ((',' star_target))* ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty a;
        asdl_seq * b;
        if (
            (a = star_target_rule(p))  // star_target
            &&
            (b = _loop0_117_rule(p))  // ((',' star_target))*
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ star_targets[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_target ((',' star_target))* ','?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Tuple ( CHECK ( _PyPegen_seq_insert_in_front ( p , a , b ) ) , Store , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_targets[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_target ((',' star_target))* ','?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_targets_list_seq: ','.star_target+ ','?
static asdl_seq*
star_targets_list_seq_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.star_target+ ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_targets_list_seq[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.star_target+ ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_seq * a;
        if (
            (a = _gather_118_rule(p))  // ','.star_target+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ star_targets_list_seq[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.star_target+ ','?"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_targets_list_seq[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.star_target+ ','?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_targets_tuple_seq: star_target ((',' star_target))+ ','? | star_target ','
static asdl_seq*
star_targets_tuple_seq_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // star_target ((',' star_target))+ ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_targets_tuple_seq[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_target ((',' star_target))+ ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty a;
        asdl_seq * b;
        if (
            (a = star_target_rule(p))  // star_target
            &&
            (b = _loop1_120_rule(p))  // ((',' star_target))+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ star_targets_tuple_seq[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_target ((',' star_target))+ ','?"));
            _res = _PyPegen_seq_insert_in_front ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_targets_tuple_seq[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_target ((',' star_target))+ ','?"));
    }
    { // star_target ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_targets_tuple_seq[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_target ','"));
        Token * _literal;
        expr_ty a;
        if (
            (a = star_target_rule(p))  // star_target
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ star_targets_tuple_seq[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_target ','"));
            _res = _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_targets_tuple_seq[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_target ','"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_target: '*' (!'*' star_target) | target_with_star_atom
static expr_ty
star_target_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, star_target_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '*' (!'*' star_target)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_target[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*' (!'*' star_target)"));
        Token * _literal;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = _tmp_121_rule(p))  // !'*' star_target
        )
        {
            D(fprintf(stderr, "%*c+ star_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' (!'*' star_target)"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Starred ( CHECK ( _PyPegen_set_expr_context ( p , a , Store ) ) , Store , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_target[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*' (!'*' star_target)"));
    }
    { // target_with_star_atom
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_target[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "target_with_star_atom"));
        expr_ty target_with_star_atom_var;
        if (
            (target_with_star_atom_var = target_with_star_atom_rule(p))  // target_with_star_atom
        )
        {
            D(fprintf(stderr, "%*c+ star_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "target_with_star_atom"));
            _res = target_with_star_atom_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_target[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "target_with_star_atom"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, star_target_type, _res);
    p->level--;
    return _res;
}

// target_with_star_atom:
//     | t_primary '.' NAME !t_lookahead
//     | t_primary '[' slices ']' !t_lookahead
//     | star_atom
static expr_ty
target_with_star_atom_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, target_with_star_atom_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // t_primary '.' NAME !t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> target_with_star_atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "t_primary '.' NAME !t_lookahead"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
            &&
            (b = _PyPegen_name_token(p))  // NAME
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ target_with_star_atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary '.' NAME !t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Attribute ( a , b -> v . Name . id , Store , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s target_with_star_atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "t_primary '.' NAME !t_lookahead"));
    }
    { // t_primary '[' slices ']' !t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> target_with_star_atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "t_primary '[' slices ']' !t_lookahead"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        expr_ty b;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (b = slices_rule(p))  // slices
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ target_with_star_atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary '[' slices ']' !t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Subscript ( a , b , Store , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s target_with_star_atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "t_primary '[' slices ']' !t_lookahead"));
    }
    { // star_atom
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> target_with_star_atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_atom"));
        expr_ty star_atom_var;
        if (
            (star_atom_var = star_atom_rule(p))  // star_atom
        )
        {
            D(fprintf(stderr, "%*c+ target_with_star_atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_atom"));
            _res = star_atom_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s target_with_star_atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_atom"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, target_with_star_atom_type, _res);
    p->level--;
    return _res;
}

// star_atom:
//     | NAME
//     | '(' target_with_star_atom ')'
//     | '(' star_targets_tuple_seq? ')'
//     | '[' star_targets_list_seq? ']'
static expr_ty
star_atom_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NAME"));
        expr_ty a;
        if (
            (a = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ star_atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME"));
            _res = _PyPegen_set_expr_context ( p , a , Store );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NAME"));
    }
    { // '(' target_with_star_atom ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'(' target_with_star_atom ')'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = target_with_star_atom_rule(p))  // target_with_star_atom
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ star_atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' target_with_star_atom ')'"));
            _res = _PyPegen_set_expr_context ( p , a , Store );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'(' target_with_star_atom ')'"));
    }
    { // '(' star_targets_tuple_seq? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'(' star_targets_tuple_seq? ')'"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = star_targets_tuple_seq_rule(p), !p->error_indicator)  // star_targets_tuple_seq?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ star_atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' star_targets_tuple_seq? ')'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Tuple ( a , Store , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'(' star_targets_tuple_seq? ')'"));
    }
    { // '[' star_targets_list_seq? ']'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'[' star_targets_list_seq? ']'"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (a = star_targets_list_seq_rule(p), !p->error_indicator)  // star_targets_list_seq?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
        )
        {
            D(fprintf(stderr, "%*c+ star_atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'[' star_targets_list_seq? ']'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_List ( a , Store , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'[' star_targets_list_seq? ']'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// single_target: single_subscript_attribute_target | NAME | '(' single_target ')'
static expr_ty
single_target_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // single_subscript_attribute_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> single_target[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "single_subscript_attribute_target"));
        expr_ty single_subscript_attribute_target_var;
        if (
            (single_subscript_attribute_target_var = single_subscript_attribute_target_rule(p))  // single_subscript_attribute_target
        )
        {
            D(fprintf(stderr, "%*c+ single_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "single_subscript_attribute_target"));
            _res = single_subscript_attribute_target_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s single_target[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "single_subscript_attribute_target"));
    }
    { // NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> single_target[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NAME"));
        expr_ty a;
        if (
            (a = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ single_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME"));
            _res = _PyPegen_set_expr_context ( p , a , Store );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s single_target[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NAME"));
    }
    { // '(' single_target ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> single_target[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'(' single_target ')'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = single_target_rule(p))  // single_target
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ single_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' single_target ')'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s single_target[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'(' single_target ')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// single_subscript_attribute_target:
//     | t_primary '.' NAME !t_lookahead
//     | t_primary '[' slices ']' !t_lookahead
static expr_ty
single_subscript_attribute_target_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // t_primary '.' NAME !t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> single_subscript_attribute_target[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "t_primary '.' NAME !t_lookahead"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
            &&
            (b = _PyPegen_name_token(p))  // NAME
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ single_subscript_attribute_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary '.' NAME !t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Attribute ( a , b -> v . Name . id , Store , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s single_subscript_attribute_target[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "t_primary '.' NAME !t_lookahead"));
    }
    { // t_primary '[' slices ']' !t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> single_subscript_attribute_target[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "t_primary '[' slices ']' !t_lookahead"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        expr_ty b;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (b = slices_rule(p))  // slices
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ single_subscript_attribute_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary '[' slices ']' !t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Subscript ( a , b , Store , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s single_subscript_attribute_target[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "t_primary '[' slices ']' !t_lookahead"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// del_targets: ','.del_target+ ','?
static asdl_seq*
del_targets_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.del_target+ ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_targets[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','.del_target+ ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_seq * a;
        if (
            (a = _gather_122_rule(p))  // ','.del_target+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ del_targets[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.del_target+ ','?"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_targets[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','.del_target+ ','?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// del_target:
//     | t_primary '.' NAME !t_lookahead
//     | t_primary '[' slices ']' !t_lookahead
//     | del_t_atom
static expr_ty
del_target_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, del_target_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // t_primary '.' NAME !t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_target[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "t_primary '.' NAME !t_lookahead"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
            &&
            (b = _PyPegen_name_token(p))  // NAME
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ del_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary '.' NAME !t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Attribute ( a , b -> v . Name . id , Del , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_target[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "t_primary '.' NAME !t_lookahead"));
    }
    { // t_primary '[' slices ']' !t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_target[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "t_primary '[' slices ']' !t_lookahead"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        expr_ty b;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (b = slices_rule(p))  // slices
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ del_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary '[' slices ']' !t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Subscript ( a , b , Del , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_target[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "t_primary '[' slices ']' !t_lookahead"));
    }
    { // del_t_atom
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_target[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "del_t_atom"));
        expr_ty del_t_atom_var;
        if (
            (del_t_atom_var = del_t_atom_rule(p))  // del_t_atom
        )
        {
            D(fprintf(stderr, "%*c+ del_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "del_t_atom"));
            _res = del_t_atom_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_target[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "del_t_atom"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, del_target_type, _res);
    p->level--;
    return _res;
}

// del_t_atom: NAME | '(' del_target ')' | '(' del_targets? ')' | '[' del_targets? ']'
static expr_ty
del_t_atom_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_t_atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NAME"));
        expr_ty a;
        if (
            (a = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ del_t_atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME"));
            _res = _PyPegen_set_expr_context ( p , a , Del );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_t_atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NAME"));
    }
    { // '(' del_target ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_t_atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'(' del_target ')'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = del_target_rule(p))  // del_target
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ del_t_atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' del_target ')'"));
            _res = _PyPegen_set_expr_context ( p , a , Del );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_t_atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'(' del_target ')'"));
    }
    { // '(' del_targets? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_t_atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'(' del_targets? ')'"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = del_targets_rule(p), !p->error_indicator)  // del_targets?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ del_t_atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' del_targets? ')'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Tuple ( a , Del , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_t_atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'(' del_targets? ')'"));
    }
    { // '[' del_targets? ']'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_t_atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'[' del_targets? ']'"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (a = del_targets_rule(p), !p->error_indicator)  // del_targets?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
        )
        {
            D(fprintf(stderr, "%*c+ del_t_atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'[' del_targets? ']'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_List ( a , Del , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_t_atom[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'[' del_targets? ']'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// t_primary:
//     | t_primary '.' NAME &t_lookahead
//     | t_primary '[' slices ']' &t_lookahead
//     | t_primary genexp &t_lookahead
//     | t_primary '(' arguments? ')' &t_lookahead
//     | atom &t_lookahead
static expr_ty t_primary_raw(Parser *);
static expr_ty
t_primary_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, t_primary_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_8 = _PyPegen_update_memo(p, _mark, t_primary_type, _res);
        if (tmpvar_8) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = t_primary_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
t_primary_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // t_primary '.' NAME &t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> t_primary[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "t_primary '.' NAME &t_lookahead"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
            &&
            (b = _PyPegen_name_token(p))  // NAME
            &&
            _PyPegen_lookahead(1, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ t_primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary '.' NAME &t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Attribute ( a , b -> v . Name . id , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s t_primary[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "t_primary '.' NAME &t_lookahead"));
    }
    { // t_primary '[' slices ']' &t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> t_primary[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "t_primary '[' slices ']' &t_lookahead"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        expr_ty b;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (b = slices_rule(p))  // slices
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
            &&
            _PyPegen_lookahead(1, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ t_primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary '[' slices ']' &t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Subscript ( a , b , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s t_primary[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "t_primary '[' slices ']' &t_lookahead"));
    }
    { // t_primary genexp &t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> t_primary[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "t_primary genexp &t_lookahead"));
        expr_ty a;
        expr_ty b;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (b = genexp_rule(p))  // genexp
            &&
            _PyPegen_lookahead(1, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ t_primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary genexp &t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Call ( a , CHECK ( _PyPegen_singleton_seq ( p , b ) ) , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s t_primary[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "t_primary genexp &t_lookahead"));
    }
    { // t_primary '(' arguments? ')' &t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> t_primary[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "t_primary '(' arguments? ')' &t_lookahead"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        void *b;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (b = arguments_rule(p), !p->error_indicator)  // arguments?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            _PyPegen_lookahead(1, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ t_primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary '(' arguments? ')' &t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_Call ( a , ( b ) ? ( ( expr_ty ) b ) -> v . Call . args : NULL , ( b ) ? ( ( expr_ty ) b ) -> v . Call . keywords : NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s t_primary[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "t_primary '(' arguments? ')' &t_lookahead"));
    }
    { // atom &t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> t_primary[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "atom &t_lookahead"));
        expr_ty a;
        if (
            (a = atom_rule(p))  // atom
            &&
            _PyPegen_lookahead(1, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ t_primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "atom &t_lookahead"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s t_primary[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "atom &t_lookahead"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// t_lookahead: '(' | '[' | '.'
static void *
t_lookahead_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '('
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> t_lookahead[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'('"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
        )
        {
            D(fprintf(stderr, "%*c+ t_lookahead[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'('"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s t_lookahead[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'('"));
    }
    { // '['
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> t_lookahead[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'['"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
        )
        {
            D(fprintf(stderr, "%*c+ t_lookahead[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'['"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s t_lookahead[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'['"));
    }
    { // '.'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> t_lookahead[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'.'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
        )
        {
            D(fprintf(stderr, "%*c+ t_lookahead[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'.'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s t_lookahead[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'.'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_arguments:
//     | args ',' '*'
//     | expression for_if_clauses ',' [args | expression for_if_clauses]
//     | args for_if_clauses
//     | args ',' expression for_if_clauses
//     | args ',' args
static void *
invalid_arguments_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // args ',' '*'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_arguments[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "args ',' '*'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty args_var;
        if (
            (args_var = args_rule(p))  // args
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_literal_1 = _PyPegen_expect_token(p, 16))  // token='*'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_arguments[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "args ',' '*'"));
            _res = RAISE_SYNTAX_ERROR ( "iterable argument unpacking follows keyword argument unpacking" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_arguments[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "args ',' '*'"));
    }
    { // expression for_if_clauses ',' [args | expression for_if_clauses]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_arguments[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression for_if_clauses ',' [args | expression for_if_clauses]"));
        Token * _literal;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty a;
        asdl_seq* for_if_clauses_var;
        if (
            (a = expression_rule(p))  // expression
            &&
            (for_if_clauses_var = for_if_clauses_rule(p))  // for_if_clauses
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_opt_var = _tmp_124_rule(p), !p->error_indicator)  // [args | expression for_if_clauses]
        )
        {
            D(fprintf(stderr, "%*c+ invalid_arguments[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression for_if_clauses ',' [args | expression for_if_clauses]"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "Generator expression must be parenthesized" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_arguments[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression for_if_clauses ',' [args | expression for_if_clauses]"));
    }
    { // args for_if_clauses
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_arguments[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "args for_if_clauses"));
        expr_ty a;
        asdl_seq* for_if_clauses_var;
        if (
            (a = args_rule(p))  // args
            &&
            (for_if_clauses_var = for_if_clauses_rule(p))  // for_if_clauses
        )
        {
            D(fprintf(stderr, "%*c+ invalid_arguments[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "args for_if_clauses"));
            _res = _PyPegen_nonparen_genexp_in_call ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_arguments[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "args for_if_clauses"));
    }
    { // args ',' expression for_if_clauses
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_arguments[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "args ',' expression for_if_clauses"));
        Token * _literal;
        expr_ty a;
        expr_ty args_var;
        asdl_seq* for_if_clauses_var;
        if (
            (args_var = args_rule(p))  // args
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (a = expression_rule(p))  // expression
            &&
            (for_if_clauses_var = for_if_clauses_rule(p))  // for_if_clauses
        )
        {
            D(fprintf(stderr, "%*c+ invalid_arguments[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "args ',' expression for_if_clauses"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "Generator expression must be parenthesized" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_arguments[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "args ',' expression for_if_clauses"));
    }
    { // args ',' args
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_arguments[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "args ',' args"));
        Token * _literal;
        expr_ty a;
        expr_ty args_var;
        if (
            (a = args_rule(p))  // args
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (args_var = args_rule(p))  // args
        )
        {
            D(fprintf(stderr, "%*c+ invalid_arguments[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "args ',' args"));
            _res = _PyPegen_arguments_parsing_error ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_arguments[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "args ',' args"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_kwarg: !(NAME '=') expression '='
static void *
invalid_kwarg_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // !(NAME '=') expression '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_kwarg[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "!(NAME '=') expression '='"));
        expr_ty a;
        Token * b;
        if (
            _PyPegen_lookahead(0, _tmp_125_rule, p)
            &&
            (a = expression_rule(p))  // expression
            &&
            (b = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ invalid_kwarg[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "!(NAME '=') expression '='"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "expression cannot contain assignment, perhaps you meant \"==\"?" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_kwarg[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "!(NAME '=') expression '='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_named_expression: expression ':=' expression
static void *
invalid_named_expression_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // expression ':=' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_named_expression[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression ':=' expression"));
        Token * _literal;
        expr_ty a;
        expr_ty expression_var;
        if (
            (a = expression_rule(p))  // expression
            &&
            (_literal = _PyPegen_expect_token(p, 53))  // token=':='
            &&
            (expression_var = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ invalid_named_expression[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression ':=' expression"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "cannot use assignment expressions with %s" , _PyPegen_get_expr_name ( a ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_named_expression[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression ':=' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_assignment:
//     | invalid_ann_assign_target ':' expression
//     | star_named_expression ',' star_named_expressions* ':' expression
//     | expression ':' expression
//     | ((star_targets '='))* star_expressions '='
//     | ((star_targets '='))* yield_expr '='
//     | star_expressions augassign (yield_expr | star_expressions)
static void *
invalid_assignment_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // invalid_ann_assign_target ':' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_assignment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_ann_assign_target ':' expression"));
        Token * _literal;
        expr_ty a;
        expr_ty expression_var;
        if (
            (a = invalid_ann_assign_target_rule(p))  // invalid_ann_assign_target
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (expression_var = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ invalid_assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_ann_assign_target ':' expression"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "only single target (not %s) can be annotated" , _PyPegen_get_expr_name ( a ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_assignment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_ann_assign_target ':' expression"));
    }
    { // star_named_expression ',' star_named_expressions* ':' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_assignment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_named_expression ',' star_named_expressions* ':' expression"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * _loop0_126_var;
        expr_ty a;
        expr_ty expression_var;
        if (
            (a = star_named_expression_rule(p))  // star_named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_loop0_126_var = _loop0_126_rule(p))  // star_named_expressions*
            &&
            (_literal_1 = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (expression_var = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ invalid_assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_named_expression ',' star_named_expressions* ':' expression"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "only single target (not tuple) can be annotated" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_assignment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_named_expression ',' star_named_expressions* ':' expression"));
    }
    { // expression ':' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_assignment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression ':' expression"));
        Token * _literal;
        expr_ty a;
        expr_ty expression_var;
        if (
            (a = expression_rule(p))  // expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (expression_var = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ invalid_assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression ':' expression"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "illegal target for annotation" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_assignment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression ':' expression"));
    }
    { // ((star_targets '='))* star_expressions '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_assignment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "((star_targets '='))* star_expressions '='"));
        Token * _literal;
        asdl_seq * _loop0_127_var;
        expr_ty a;
        if (
            (_loop0_127_var = _loop0_127_rule(p))  // ((star_targets '='))*
            &&
            (a = star_expressions_rule(p))  // star_expressions
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ invalid_assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "((star_targets '='))* star_expressions '='"));
            _res = RAISE_SYNTAX_ERROR_INVALID_TARGET ( STAR_TARGETS , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_assignment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "((star_targets '='))* star_expressions '='"));
    }
    { // ((star_targets '='))* yield_expr '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_assignment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "((star_targets '='))* yield_expr '='"));
        Token * _literal;
        asdl_seq * _loop0_128_var;
        expr_ty a;
        if (
            (_loop0_128_var = _loop0_128_rule(p))  // ((star_targets '='))*
            &&
            (a = yield_expr_rule(p))  // yield_expr
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ invalid_assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "((star_targets '='))* yield_expr '='"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "assignment to yield expression not possible" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_assignment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "((star_targets '='))* yield_expr '='"));
    }
    { // star_expressions augassign (yield_expr | star_expressions)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_assignment[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_expressions augassign (yield_expr | star_expressions)"));
        void *_tmp_129_var;
        expr_ty a;
        AugOperator* augassign_var;
        if (
            (a = star_expressions_rule(p))  // star_expressions
            &&
            (augassign_var = augassign_rule(p))  // augassign
            &&
            (_tmp_129_var = _tmp_129_rule(p))  // yield_expr | star_expressions
        )
        {
            D(fprintf(stderr, "%*c+ invalid_assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_expressions augassign (yield_expr | star_expressions)"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "'%s' is an illegal expression for augmented assignment" , _PyPegen_get_expr_name ( a ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_assignment[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_expressions augassign (yield_expr | star_expressions)"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_ann_assign_target: list | tuple | '(' invalid_ann_assign_target ')'
static expr_ty
invalid_ann_assign_target_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // list
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_ann_assign_target[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "list"));
        expr_ty list_var;
        if (
            (list_var = list_rule(p))  // list
        )
        {
            D(fprintf(stderr, "%*c+ invalid_ann_assign_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "list"));
            _res = list_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_ann_assign_target[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "list"));
    }
    { // tuple
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_ann_assign_target[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "tuple"));
        expr_ty tuple_var;
        if (
            (tuple_var = tuple_rule(p))  // tuple
        )
        {
            D(fprintf(stderr, "%*c+ invalid_ann_assign_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "tuple"));
            _res = tuple_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_ann_assign_target[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "tuple"));
    }
    { // '(' invalid_ann_assign_target ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_ann_assign_target[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'(' invalid_ann_assign_target ')'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = invalid_ann_assign_target_rule(p))  // invalid_ann_assign_target
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_ann_assign_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' invalid_ann_assign_target ')'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_ann_assign_target[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'(' invalid_ann_assign_target ')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_del_stmt: 'del' star_expressions
static void *
invalid_del_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'del' star_expressions
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_del_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'del' star_expressions"));
        Token * _keyword;
        expr_ty a;
        if (
            (_keyword = _PyPegen_expect_token(p, 503))  // token='del'
            &&
            (a = star_expressions_rule(p))  // star_expressions
        )
        {
            D(fprintf(stderr, "%*c+ invalid_del_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'del' star_expressions"));
            _res = RAISE_SYNTAX_ERROR_INVALID_TARGET ( DEL_TARGETS , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_del_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'del' star_expressions"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_block: NEWLINE !INDENT
static void *
invalid_block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // NEWLINE !INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_block[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NEWLINE !INDENT"));
        Token * newline_var;
        if (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
        )
        {
            D(fprintf(stderr, "%*c+ invalid_block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NEWLINE !INDENT"));
            _res = RAISE_INDENTATION_ERROR ( "expected an indented block" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_block[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NEWLINE !INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// invalid_primary: primary '{'
static void *
invalid_primary_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // primary '{'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_primary[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "primary '{'"));
        Token * a;
        expr_ty primary_var;
        if (
            (primary_var = primary_rule(p))  // primary
            &&
            (a = _PyPegen_expect_token(p, 25))  // token='{'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "primary '{'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "invalid syntax" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_primary[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "primary '{'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_comprehension: ('[' | '(' | '{') starred_expression for_if_clauses
static void *
invalid_comprehension_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ('[' | '(' | '{') starred_expression for_if_clauses
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_comprehension[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "('[' | '(' | '{') starred_expression for_if_clauses"));
        void *_tmp_130_var;
        expr_ty a;
        asdl_seq* for_if_clauses_var;
        if (
            (_tmp_130_var = _tmp_130_rule(p))  // '[' | '(' | '{'
            &&
            (a = starred_expression_rule(p))  // starred_expression
            &&
            (for_if_clauses_var = for_if_clauses_rule(p))  // for_if_clauses
        )
        {
            D(fprintf(stderr, "%*c+ invalid_comprehension[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "('[' | '(' | '{') starred_expression for_if_clauses"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "iterable unpacking cannot be used in comprehension" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_comprehension[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "('[' | '(' | '{') starred_expression for_if_clauses"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_dict_comprehension: '{' '**' bitwise_or for_if_clauses '}'
static void *
invalid_dict_comprehension_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '{' '**' bitwise_or for_if_clauses '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_dict_comprehension[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'{' '**' bitwise_or for_if_clauses '}'"));
        Token * _literal;
        Token * _literal_1;
        Token * a;
        expr_ty bitwise_or_var;
        asdl_seq* for_if_clauses_var;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (a = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (bitwise_or_var = bitwise_or_rule(p))  // bitwise_or
            &&
            (for_if_clauses_var = for_if_clauses_rule(p))  // for_if_clauses
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_dict_comprehension[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'{' '**' bitwise_or for_if_clauses '}'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "dict unpacking cannot be used in dict comprehension" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_dict_comprehension[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'{' '**' bitwise_or for_if_clauses '}'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_parameters:
//     | param_no_default* (slash_with_default | param_with_default+) param_no_default
static void *
invalid_parameters_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // param_no_default* (slash_with_default | param_with_default+) param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_parameters[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_no_default* (slash_with_default | param_with_default+) param_no_default"));
        asdl_seq * _loop0_131_var;
        void *_tmp_132_var;
        arg_ty param_no_default_var;
        if (
            (_loop0_131_var = _loop0_131_rule(p))  // param_no_default*
            &&
            (_tmp_132_var = _tmp_132_rule(p))  // slash_with_default | param_with_default+
            &&
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ invalid_parameters[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "param_no_default* (slash_with_default | param_with_default+) param_no_default"));
            _res = RAISE_SYNTAX_ERROR ( "non-default argument follows default argument" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_parameters[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_no_default* (slash_with_default | param_with_default+) param_no_default"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_lambda_parameters:
//     | lambda_param_no_default* (lambda_slash_with_default | lambda_param_with_default+) lambda_param_no_default
static void *
invalid_lambda_parameters_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // lambda_param_no_default* (lambda_slash_with_default | lambda_param_with_default+) lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_parameters[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default* (lambda_slash_with_default | lambda_param_with_default+) lambda_param_no_default"));
        asdl_seq * _loop0_133_var;
        void *_tmp_134_var;
        arg_ty lambda_param_no_default_var;
        if (
            (_loop0_133_var = _loop0_133_rule(p))  // lambda_param_no_default*
            &&
            (_tmp_134_var = _tmp_134_rule(p))  // lambda_slash_with_default | lambda_param_with_default+
            &&
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_parameters[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default* (lambda_slash_with_default | lambda_param_with_default+) lambda_param_no_default"));
            _res = RAISE_SYNTAX_ERROR ( "non-default argument follows default argument" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_parameters[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_no_default* (lambda_slash_with_default | lambda_param_with_default+) lambda_param_no_default"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_star_etc: '*' (')' | ',' (')' | '**')) | '*' ',' TYPE_COMMENT
static void *
invalid_star_etc_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '*' (')' | ',' (')' | '**'))
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_star_etc[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*' (')' | ',' (')' | '**'))"));
        Token * _literal;
        void *_tmp_135_var;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_tmp_135_var = _tmp_135_rule(p))  // ')' | ',' (')' | '**')
        )
        {
            D(fprintf(stderr, "%*c+ invalid_star_etc[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' (')' | ',' (')' | '**'))"));
            _res = RAISE_SYNTAX_ERROR ( "named arguments must follow bare *" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_star_etc[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*' (')' | ',' (')' | '**'))"));
    }
    { // '*' ',' TYPE_COMMENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_star_etc[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*' ',' TYPE_COMMENT"));
        Token * _literal;
        Token * _literal_1;
        Token * type_comment_var;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (type_comment_var = _PyPegen_expect_token(p, TYPE_COMMENT))  // token='TYPE_COMMENT'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_star_etc[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' ',' TYPE_COMMENT"));
            _res = RAISE_SYNTAX_ERROR ( "bare * has associated type comment" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_star_etc[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*' ',' TYPE_COMMENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_lambda_star_etc: '*' (':' | ',' (':' | '**'))
static void *
invalid_lambda_star_etc_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '*' (':' | ',' (':' | '**'))
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_star_etc[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'*' (':' | ',' (':' | '**'))"));
        Token * _literal;
        void *_tmp_136_var;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_tmp_136_var = _tmp_136_rule(p))  // ':' | ',' (':' | '**')
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_star_etc[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' (':' | ',' (':' | '**'))"));
            _res = RAISE_SYNTAX_ERROR ( "named arguments must follow bare *" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_star_etc[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'*' (':' | ',' (':' | '**'))"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_double_type_comments: TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT
static void *
invalid_double_type_comments_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_double_type_comments[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT"));
        Token * indent_var;
        Token * newline_var;
        Token * newline_var_1;
        Token * type_comment_var;
        Token * type_comment_var_1;
        if (
            (type_comment_var = _PyPegen_expect_token(p, TYPE_COMMENT))  // token='TYPE_COMMENT'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (type_comment_var_1 = _PyPegen_expect_token(p, TYPE_COMMENT))  // token='TYPE_COMMENT'
            &&
            (newline_var_1 = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (indent_var = _PyPegen_expect_token(p, INDENT))  // token='INDENT'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_double_type_comments[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT"));
            _res = RAISE_SYNTAX_ERROR ( "Cannot have two type comments on def" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_double_type_comments[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_with_item: expression 'as' expression
static void *
invalid_with_item_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // expression 'as' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_with_item[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression 'as' expression"));
        Token * _keyword;
        expr_ty a;
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
            &&
            (_keyword = _PyPegen_expect_token(p, 520))  // token='as'
            &&
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ invalid_with_item[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression 'as' expression"));
            _res = RAISE_SYNTAX_ERROR_INVALID_TARGET ( STAR_TARGETS , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_with_item[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression 'as' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_for_target: ASYNC? 'for' star_expressions
static void *
invalid_for_target_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ASYNC? 'for' star_expressions
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_for_target[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "ASYNC? 'for' star_expressions"));
        Token * _keyword;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty a;
        if (
            (_opt_var = _PyPegen_expect_token(p, ASYNC), !p->error_indicator)  // ASYNC?
            &&
            (_keyword = _PyPegen_expect_token(p, 517))  // token='for'
            &&
            (a = star_expressions_rule(p))  // star_expressions
        )
        {
            D(fprintf(stderr, "%*c+ invalid_for_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "ASYNC? 'for' star_expressions"));
            _res = RAISE_SYNTAX_ERROR_INVALID_TARGET ( FOR_TARGETS , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_for_target[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "ASYNC? 'for' star_expressions"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_group: '(' starred_expression ')'
static void *
invalid_group_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '(' starred_expression ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_group[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'(' starred_expression ')'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = starred_expression_rule(p))  // starred_expression
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_group[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' starred_expression ')'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "can't use starred expression here" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_group[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'(' starred_expression ')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_import_from_targets: import_from_as_names ',' NEWLINE
static void *
invalid_import_from_targets_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // import_from_as_names ',' NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_import_from_targets[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "import_from_as_names ',' NEWLINE"));
        Token * _literal;
        asdl_seq* import_from_as_names_var;
        Token * newline_var;
        if (
            (import_from_as_names_var = import_from_as_names_rule(p))  // import_from_as_names
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_import_from_targets[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "import_from_as_names ',' NEWLINE"));
            _res = RAISE_SYNTAX_ERROR ( "trailing comma not allowed without surrounding parentheses" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_import_from_targets[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "import_from_as_names ',' NEWLINE"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_1: NEWLINE
static asdl_seq *
_loop0_1_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_1[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NEWLINE"));
        Token * newline_var;
        while (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            _res = newline_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_1[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NEWLINE"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_1_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_2: NEWLINE
static asdl_seq *
_loop0_2_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_2[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NEWLINE"));
        Token * newline_var;
        while (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            _res = newline_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_2[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NEWLINE"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_2_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_4: ',' expression
static asdl_seq *
_loop0_4_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_4[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' expression"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = expression_rule(p))  // expression
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_4[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' expression"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_4_type, _seq);
    p->level--;
    return _seq;
}

// _gather_3: expression _loop0_4
static asdl_seq *
_gather_3_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // expression _loop0_4
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_3[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression _loop0_4"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = expression_rule(p))  // expression
            &&
            (seq = _loop0_4_rule(p))  // _loop0_4
        )
        {
            D(fprintf(stderr, "%*c+ _gather_3[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression _loop0_4"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_3[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression _loop0_4"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_6: ',' expression
static asdl_seq *
_loop0_6_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_6[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' expression"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = expression_rule(p))  // expression
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_6[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' expression"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_6_type, _seq);
    p->level--;
    return _seq;
}

// _gather_5: expression _loop0_6
static asdl_seq *
_gather_5_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // expression _loop0_6
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_5[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression _loop0_6"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = expression_rule(p))  // expression
            &&
            (seq = _loop0_6_rule(p))  // _loop0_6
        )
        {
            D(fprintf(stderr, "%*c+ _gather_5[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression _loop0_6"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_5[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression _loop0_6"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_8: ',' expression
static asdl_seq *
_loop0_8_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_8[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' expression"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = expression_rule(p))  // expression
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_8[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' expression"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_8_type, _seq);
    p->level--;
    return _seq;
}

// _gather_7: expression _loop0_8
static asdl_seq *
_gather_7_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // expression _loop0_8
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_7[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression _loop0_8"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = expression_rule(p))  // expression
            &&
            (seq = _loop0_8_rule(p))  // _loop0_8
        )
        {
            D(fprintf(stderr, "%*c+ _gather_7[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression _loop0_8"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_7[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression _loop0_8"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_10: ',' expression
static asdl_seq *
_loop0_10_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_10[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' expression"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = expression_rule(p))  // expression
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_10[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' expression"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_10_type, _seq);
    p->level--;
    return _seq;
}

// _gather_9: expression _loop0_10
static asdl_seq *
_gather_9_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // expression _loop0_10
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_9[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression _loop0_10"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = expression_rule(p))  // expression
            &&
            (seq = _loop0_10_rule(p))  // _loop0_10
        )
        {
            D(fprintf(stderr, "%*c+ _gather_9[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression _loop0_10"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_9[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression _loop0_10"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_11: statement
static asdl_seq *
_loop1_11_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // statement
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_11[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "statement"));
        asdl_seq* statement_var;
        while (
            (statement_var = statement_rule(p))  // statement
        )
        {
            _res = statement_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_11[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "statement"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_11_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_13: ';' small_stmt
static asdl_seq *
_loop0_13_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ';' small_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_13[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "';' small_stmt"));
        Token * _literal;
        stmt_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 13))  // token=';'
            &&
            (elem = small_stmt_rule(p))  // small_stmt
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_13[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "';' small_stmt"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_13_type, _seq);
    p->level--;
    return _seq;
}

// _gather_12: small_stmt _loop0_13
static asdl_seq *
_gather_12_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // small_stmt _loop0_13
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_12[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "small_stmt _loop0_13"));
        stmt_ty elem;
        asdl_seq * seq;
        if (
            (elem = small_stmt_rule(p))  // small_stmt
            &&
            (seq = _loop0_13_rule(p))  // _loop0_13
        )
        {
            D(fprintf(stderr, "%*c+ _gather_12[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "small_stmt _loop0_13"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_12[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "small_stmt _loop0_13"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_14: 'import' | 'from'
static void *
_tmp_14_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'import'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_14[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'import'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 513))  // token='import'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_14[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'import'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_14[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'import'"));
    }
    { // 'from'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_14[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'from'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 514))  // token='from'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_14[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'from'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_14[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'from'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_15: 'def' | '@' | ASYNC
static void *
_tmp_15_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'def'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_15[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'def'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 523))  // token='def'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_15[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'def'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_15[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'def'"));
    }
    { // '@'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_15[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'@'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 49))  // token='@'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_15[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'@'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_15[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'@'"));
    }
    { // ASYNC
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_15[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "ASYNC"));
        Token * async_var;
        if (
            (async_var = _PyPegen_expect_token(p, ASYNC))  // token='ASYNC'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_15[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "ASYNC"));
            _res = async_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_15[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "ASYNC"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_16: 'class' | '@'
static void *
_tmp_16_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'class'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_16[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'class'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 524))  // token='class'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_16[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'class'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_16[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'class'"));
    }
    { // '@'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_16[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'@'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 49))  // token='@'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_16[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'@'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_16[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'@'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_17: 'with' | ASYNC
static void *
_tmp_17_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'with'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_17[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'with'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 519))  // token='with'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_17[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'with'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_17[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'with'"));
    }
    { // ASYNC
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_17[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "ASYNC"));
        Token * async_var;
        if (
            (async_var = _PyPegen_expect_token(p, ASYNC))  // token='ASYNC'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_17[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "ASYNC"));
            _res = async_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_17[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "ASYNC"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_18: 'for' | ASYNC
static void *
_tmp_18_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'for'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_18[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'for'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 517))  // token='for'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_18[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'for'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_18[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'for'"));
    }
    { // ASYNC
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_18[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "ASYNC"));
        Token * async_var;
        if (
            (async_var = _PyPegen_expect_token(p, ASYNC))  // token='ASYNC'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_18[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "ASYNC"));
            _res = async_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_18[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "ASYNC"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_19: '=' annotated_rhs
static void *
_tmp_19_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '=' annotated_rhs
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_19[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'=' annotated_rhs"));
        Token * _literal;
        expr_ty d;
        if (
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (d = annotated_rhs_rule(p))  // annotated_rhs
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_19[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'=' annotated_rhs"));
            _res = d;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_19[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'=' annotated_rhs"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_20: '(' single_target ')' | single_subscript_attribute_target
static void *
_tmp_20_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '(' single_target ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_20[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'(' single_target ')'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty b;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (b = single_target_rule(p))  // single_target
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_20[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' single_target ')'"));
            _res = b;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_20[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'(' single_target ')'"));
    }
    { // single_subscript_attribute_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_20[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "single_subscript_attribute_target"));
        expr_ty single_subscript_attribute_target_var;
        if (
            (single_subscript_attribute_target_var = single_subscript_attribute_target_rule(p))  // single_subscript_attribute_target
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_20[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "single_subscript_attribute_target"));
            _res = single_subscript_attribute_target_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_20[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "single_subscript_attribute_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_21: '=' annotated_rhs
static void *
_tmp_21_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '=' annotated_rhs
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_21[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'=' annotated_rhs"));
        Token * _literal;
        expr_ty d;
        if (
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (d = annotated_rhs_rule(p))  // annotated_rhs
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_21[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'=' annotated_rhs"));
            _res = d;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_21[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'=' annotated_rhs"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_22: (star_targets '=')
static asdl_seq *
_loop1_22_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // (star_targets '=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_22[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "(star_targets '=')"));
        void *_tmp_137_var;
        while (
            (_tmp_137_var = _tmp_137_rule(p))  // star_targets '='
        )
        {
            _res = _tmp_137_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_22[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "(star_targets '=')"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_22_type, _seq);
    p->level--;
    return _seq;
}

// _tmp_23: yield_expr | star_expressions
static void *
_tmp_23_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // yield_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_23[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "yield_expr"));
        expr_ty yield_expr_var;
        if (
            (yield_expr_var = yield_expr_rule(p))  // yield_expr
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_23[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "yield_expr"));
            _res = yield_expr_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_23[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "yield_expr"));
    }
    { // star_expressions
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_23[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_expressions"));
        expr_ty star_expressions_var;
        if (
            (star_expressions_var = star_expressions_rule(p))  // star_expressions
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_23[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_expressions"));
            _res = star_expressions_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_23[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_expressions"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_24: yield_expr | star_expressions
static void *
_tmp_24_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // yield_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_24[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "yield_expr"));
        expr_ty yield_expr_var;
        if (
            (yield_expr_var = yield_expr_rule(p))  // yield_expr
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_24[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "yield_expr"));
            _res = yield_expr_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_24[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "yield_expr"));
    }
    { // star_expressions
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_24[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_expressions"));
        expr_ty star_expressions_var;
        if (
            (star_expressions_var = star_expressions_rule(p))  // star_expressions
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_24[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_expressions"));
            _res = star_expressions_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_24[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_expressions"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_26: ',' NAME
static asdl_seq *
_loop0_26_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_26[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' NAME"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = _PyPegen_name_token(p))  // NAME
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_26[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' NAME"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_26_type, _seq);
    p->level--;
    return _seq;
}

// _gather_25: NAME _loop0_26
static asdl_seq *
_gather_25_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // NAME _loop0_26
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_25[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NAME _loop0_26"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = _PyPegen_name_token(p))  // NAME
            &&
            (seq = _loop0_26_rule(p))  // _loop0_26
        )
        {
            D(fprintf(stderr, "%*c+ _gather_25[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME _loop0_26"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_25[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NAME _loop0_26"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_28: ',' NAME
static asdl_seq *
_loop0_28_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_28[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' NAME"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = _PyPegen_name_token(p))  // NAME
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_28[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' NAME"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_28_type, _seq);
    p->level--;
    return _seq;
}

// _gather_27: NAME _loop0_28
static asdl_seq *
_gather_27_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // NAME _loop0_28
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_27[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NAME _loop0_28"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = _PyPegen_name_token(p))  // NAME
            &&
            (seq = _loop0_28_rule(p))  // _loop0_28
        )
        {
            D(fprintf(stderr, "%*c+ _gather_27[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME _loop0_28"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_27[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NAME _loop0_28"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_29: ',' expression
static void *
_tmp_29_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ',' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_29[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' expression"));
        Token * _literal;
        expr_ty z;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (z = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_29[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "',' expression"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_29[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_30: ';' | NEWLINE
static void *
_tmp_30_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ';'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_30[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "';'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 13))  // token=';'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_30[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "';'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_30[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "';'"));
    }
    { // NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_30[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NEWLINE"));
        Token * newline_var;
        if (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_30[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NEWLINE"));
            _res = newline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_30[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NEWLINE"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_31: ('.' | '...')
static asdl_seq *
_loop0_31_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ('.' | '...')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_31[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "('.' | '...')"));
        void *_tmp_138_var;
        while (
            (_tmp_138_var = _tmp_138_rule(p))  // '.' | '...'
        )
        {
            _res = _tmp_138_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_31[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "('.' | '...')"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_31_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_32: ('.' | '...')
static asdl_seq *
_loop1_32_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ('.' | '...')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_32[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "('.' | '...')"));
        void *_tmp_139_var;
        while (
            (_tmp_139_var = _tmp_139_rule(p))  // '.' | '...'
        )
        {
            _res = _tmp_139_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_32[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "('.' | '...')"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_32_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_34: ',' import_from_as_name
static asdl_seq *
_loop0_34_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' import_from_as_name
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_34[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' import_from_as_name"));
        Token * _literal;
        alias_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = import_from_as_name_rule(p))  // import_from_as_name
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_34[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' import_from_as_name"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_34_type, _seq);
    p->level--;
    return _seq;
}

// _gather_33: import_from_as_name _loop0_34
static asdl_seq *
_gather_33_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // import_from_as_name _loop0_34
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_33[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "import_from_as_name _loop0_34"));
        alias_ty elem;
        asdl_seq * seq;
        if (
            (elem = import_from_as_name_rule(p))  // import_from_as_name
            &&
            (seq = _loop0_34_rule(p))  // _loop0_34
        )
        {
            D(fprintf(stderr, "%*c+ _gather_33[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "import_from_as_name _loop0_34"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_33[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "import_from_as_name _loop0_34"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_35: 'as' NAME
static void *
_tmp_35_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_35[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'as' NAME"));
        Token * _keyword;
        expr_ty z;
        if (
            (_keyword = _PyPegen_expect_token(p, 520))  // token='as'
            &&
            (z = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_35[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'as' NAME"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_35[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'as' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_37: ',' dotted_as_name
static asdl_seq *
_loop0_37_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' dotted_as_name
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_37[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' dotted_as_name"));
        Token * _literal;
        alias_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = dotted_as_name_rule(p))  // dotted_as_name
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_37[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' dotted_as_name"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_37_type, _seq);
    p->level--;
    return _seq;
}

// _gather_36: dotted_as_name _loop0_37
static asdl_seq *
_gather_36_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // dotted_as_name _loop0_37
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_36[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "dotted_as_name _loop0_37"));
        alias_ty elem;
        asdl_seq * seq;
        if (
            (elem = dotted_as_name_rule(p))  // dotted_as_name
            &&
            (seq = _loop0_37_rule(p))  // _loop0_37
        )
        {
            D(fprintf(stderr, "%*c+ _gather_36[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "dotted_as_name _loop0_37"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_36[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "dotted_as_name _loop0_37"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_38: 'as' NAME
static void *
_tmp_38_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_38[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'as' NAME"));
        Token * _keyword;
        expr_ty z;
        if (
            (_keyword = _PyPegen_expect_token(p, 520))  // token='as'
            &&
            (z = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_38[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'as' NAME"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_38[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'as' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_40: ',' with_item
static asdl_seq *
_loop0_40_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_40[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' with_item"));
        Token * _literal;
        withitem_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = with_item_rule(p))  // with_item
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_40[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' with_item"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_40_type, _seq);
    p->level--;
    return _seq;
}

// _gather_39: with_item _loop0_40
static asdl_seq *
_gather_39_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // with_item _loop0_40
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_39[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "with_item _loop0_40"));
        withitem_ty elem;
        asdl_seq * seq;
        if (
            (elem = with_item_rule(p))  // with_item
            &&
            (seq = _loop0_40_rule(p))  // _loop0_40
        )
        {
            D(fprintf(stderr, "%*c+ _gather_39[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "with_item _loop0_40"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_39[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "with_item _loop0_40"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_42: ',' with_item
static asdl_seq *
_loop0_42_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_42[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' with_item"));
        Token * _literal;
        withitem_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = with_item_rule(p))  // with_item
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_42[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' with_item"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_42_type, _seq);
    p->level--;
    return _seq;
}

// _gather_41: with_item _loop0_42
static asdl_seq *
_gather_41_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // with_item _loop0_42
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_41[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "with_item _loop0_42"));
        withitem_ty elem;
        asdl_seq * seq;
        if (
            (elem = with_item_rule(p))  // with_item
            &&
            (seq = _loop0_42_rule(p))  // _loop0_42
        )
        {
            D(fprintf(stderr, "%*c+ _gather_41[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "with_item _loop0_42"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_41[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "with_item _loop0_42"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_44: ',' with_item
static asdl_seq *
_loop0_44_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_44[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' with_item"));
        Token * _literal;
        withitem_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = with_item_rule(p))  // with_item
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_44[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' with_item"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_44_type, _seq);
    p->level--;
    return _seq;
}

// _gather_43: with_item _loop0_44
static asdl_seq *
_gather_43_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // with_item _loop0_44
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_43[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "with_item _loop0_44"));
        withitem_ty elem;
        asdl_seq * seq;
        if (
            (elem = with_item_rule(p))  // with_item
            &&
            (seq = _loop0_44_rule(p))  // _loop0_44
        )
        {
            D(fprintf(stderr, "%*c+ _gather_43[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "with_item _loop0_44"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_43[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "with_item _loop0_44"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_46: ',' with_item
static asdl_seq *
_loop0_46_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_46[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' with_item"));
        Token * _literal;
        withitem_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = with_item_rule(p))  // with_item
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_46[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' with_item"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_46_type, _seq);
    p->level--;
    return _seq;
}

// _gather_45: with_item _loop0_46
static asdl_seq *
_gather_45_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // with_item _loop0_46
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_45[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "with_item _loop0_46"));
        withitem_ty elem;
        asdl_seq * seq;
        if (
            (elem = with_item_rule(p))  // with_item
            &&
            (seq = _loop0_46_rule(p))  // _loop0_46
        )
        {
            D(fprintf(stderr, "%*c+ _gather_45[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "with_item _loop0_46"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_45[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "with_item _loop0_46"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_47: ',' | ')' | ':'
static void *
_tmp_47_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_47[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "','"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_47[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_47[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "','"));
    }
    { // ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_47[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "')'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_47[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "')'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_47[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "')'"));
    }
    { // ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_47[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "':'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_47[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "':'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_47[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "':'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_48: except_block
static asdl_seq *
_loop1_48_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // except_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_48[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "except_block"));
        excepthandler_ty except_block_var;
        while (
            (except_block_var = except_block_rule(p))  // except_block
        )
        {
            _res = except_block_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_48[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "except_block"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_48_type, _seq);
    p->level--;
    return _seq;
}

// _tmp_49: 'as' NAME
static void *
_tmp_49_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_49[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'as' NAME"));
        Token * _keyword;
        expr_ty z;
        if (
            (_keyword = _PyPegen_expect_token(p, 520))  // token='as'
            &&
            (z = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_49[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'as' NAME"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_49[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'as' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_50: 'from' expression
static void *
_tmp_50_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'from' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_50[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'from' expression"));
        Token * _keyword;
        expr_ty z;
        if (
            (_keyword = _PyPegen_expect_token(p, 514))  // token='from'
            &&
            (z = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_50[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'from' expression"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_50[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'from' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_51: '->' expression
static void *
_tmp_51_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '->' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_51[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'->' expression"));
        Token * _literal;
        expr_ty z;
        if (
            (_literal = _PyPegen_expect_token(p, 51))  // token='->'
            &&
            (z = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_51[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'->' expression"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_51[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'->' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_52: '->' expression
static void *
_tmp_52_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '->' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_52[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'->' expression"));
        Token * _literal;
        expr_ty z;
        if (
            (_literal = _PyPegen_expect_token(p, 51))  // token='->'
            &&
            (z = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_52[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'->' expression"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_52[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'->' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_53: NEWLINE INDENT
static void *
_tmp_53_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // NEWLINE INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_53[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NEWLINE INDENT"));
        Token * indent_var;
        Token * newline_var;
        if (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (indent_var = _PyPegen_expect_token(p, INDENT))  // token='INDENT'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_53[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NEWLINE INDENT"));
            _res = _PyPegen_dummy_name(p, newline_var, indent_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_53[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NEWLINE INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_54: param_no_default
static asdl_seq *
_loop0_54_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_54[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_no_default"));
        arg_ty param_no_default_var;
        while (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            _res = param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_54[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_no_default"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_54_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_55: param_with_default
static asdl_seq *
_loop0_55_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_55[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_with_default"));
        NameDefaultPair* param_with_default_var;
        while (
            (param_with_default_var = param_with_default_rule(p))  // param_with_default
        )
        {
            _res = param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_55[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_with_default"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_55_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_56: param_with_default
static asdl_seq *
_loop0_56_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_56[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_with_default"));
        NameDefaultPair* param_with_default_var;
        while (
            (param_with_default_var = param_with_default_rule(p))  // param_with_default
        )
        {
            _res = param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_56[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_with_default"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_56_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_57: param_no_default
static asdl_seq *
_loop1_57_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_57[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_no_default"));
        arg_ty param_no_default_var;
        while (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            _res = param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_57[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_no_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_57_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_58: param_with_default
static asdl_seq *
_loop0_58_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_58[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_with_default"));
        NameDefaultPair* param_with_default_var;
        while (
            (param_with_default_var = param_with_default_rule(p))  // param_with_default
        )
        {
            _res = param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_58[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_with_default"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_58_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_59: param_with_default
static asdl_seq *
_loop1_59_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_59[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_with_default"));
        NameDefaultPair* param_with_default_var;
        while (
            (param_with_default_var = param_with_default_rule(p))  // param_with_default
        )
        {
            _res = param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_59[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_59_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_60: param_no_default
static asdl_seq *
_loop1_60_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_60[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_no_default"));
        arg_ty param_no_default_var;
        while (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            _res = param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_60[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_no_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_60_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_61: param_no_default
static asdl_seq *
_loop1_61_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_61[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_no_default"));
        arg_ty param_no_default_var;
        while (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            _res = param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_61[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_no_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_61_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_62: param_no_default
static asdl_seq *
_loop0_62_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_62[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_no_default"));
        arg_ty param_no_default_var;
        while (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            _res = param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_62[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_no_default"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_62_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_63: param_with_default
static asdl_seq *
_loop1_63_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_63[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_with_default"));
        NameDefaultPair* param_with_default_var;
        while (
            (param_with_default_var = param_with_default_rule(p))  // param_with_default
        )
        {
            _res = param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_63[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_63_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_64: param_no_default
static asdl_seq *
_loop0_64_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_64[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_no_default"));
        arg_ty param_no_default_var;
        while (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            _res = param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_64[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_no_default"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_64_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_65: param_with_default
static asdl_seq *
_loop1_65_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_65[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_with_default"));
        NameDefaultPair* param_with_default_var;
        while (
            (param_with_default_var = param_with_default_rule(p))  // param_with_default
        )
        {
            _res = param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_65[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_65_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_66: param_maybe_default
static asdl_seq *
_loop0_66_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_66[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_maybe_default"));
        NameDefaultPair* param_maybe_default_var;
        while (
            (param_maybe_default_var = param_maybe_default_rule(p))  // param_maybe_default
        )
        {
            _res = param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_66[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_maybe_default"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_66_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_67: param_maybe_default
static asdl_seq *
_loop1_67_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_67[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_maybe_default"));
        NameDefaultPair* param_maybe_default_var;
        while (
            (param_maybe_default_var = param_maybe_default_rule(p))  // param_maybe_default
        )
        {
            _res = param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_67[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_maybe_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_67_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_68: ('@' named_expression NEWLINE)
static asdl_seq *
_loop1_68_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ('@' named_expression NEWLINE)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_68[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "('@' named_expression NEWLINE)"));
        void *_tmp_140_var;
        while (
            (_tmp_140_var = _tmp_140_rule(p))  // '@' named_expression NEWLINE
        )
        {
            _res = _tmp_140_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_68[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "('@' named_expression NEWLINE)"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_68_type, _seq);
    p->level--;
    return _seq;
}

// _tmp_69: '(' arguments? ')'
static void *
_tmp_69_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '(' arguments? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_69[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'(' arguments? ')'"));
        Token * _literal;
        Token * _literal_1;
        void *z;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (z = arguments_rule(p), !p->error_indicator)  // arguments?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_69[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' arguments? ')'"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_69[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'(' arguments? ')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_70: (',' star_expression)
static asdl_seq *
_loop1_70_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // (',' star_expression)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_70[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "(',' star_expression)"));
        void *_tmp_141_var;
        while (
            (_tmp_141_var = _tmp_141_rule(p))  // ',' star_expression
        )
        {
            _res = _tmp_141_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_70[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "(',' star_expression)"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_70_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_72: ',' star_named_expression
static asdl_seq *
_loop0_72_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' star_named_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_72[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' star_named_expression"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = star_named_expression_rule(p))  // star_named_expression
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_72[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' star_named_expression"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_72_type, _seq);
    p->level--;
    return _seq;
}

// _gather_71: star_named_expression _loop0_72
static asdl_seq *
_gather_71_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // star_named_expression _loop0_72
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_71[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_named_expression _loop0_72"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = star_named_expression_rule(p))  // star_named_expression
            &&
            (seq = _loop0_72_rule(p))  // _loop0_72
        )
        {
            D(fprintf(stderr, "%*c+ _gather_71[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_named_expression _loop0_72"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_71[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_named_expression _loop0_72"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_73: (',' expression)
static asdl_seq *
_loop1_73_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // (',' expression)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_73[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "(',' expression)"));
        void *_tmp_142_var;
        while (
            (_tmp_142_var = _tmp_142_rule(p))  // ',' expression
        )
        {
            _res = _tmp_142_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_73[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "(',' expression)"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_73_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_74: lambda_param_no_default
static asdl_seq *
_loop0_74_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_74[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default"));
        arg_ty lambda_param_no_default_var;
        while (
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            _res = lambda_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_74[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_no_default"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_74_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_75: lambda_param_with_default
static asdl_seq *
_loop0_75_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // lambda_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_75[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_with_default"));
        NameDefaultPair* lambda_param_with_default_var;
        while (
            (lambda_param_with_default_var = lambda_param_with_default_rule(p))  // lambda_param_with_default
        )
        {
            _res = lambda_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_75[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_with_default"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_75_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_76: lambda_param_with_default
static asdl_seq *
_loop0_76_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // lambda_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_76[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_with_default"));
        NameDefaultPair* lambda_param_with_default_var;
        while (
            (lambda_param_with_default_var = lambda_param_with_default_rule(p))  // lambda_param_with_default
        )
        {
            _res = lambda_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_76[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_with_default"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_76_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_77: lambda_param_no_default
static asdl_seq *
_loop1_77_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_77[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default"));
        arg_ty lambda_param_no_default_var;
        while (
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            _res = lambda_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_77[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_no_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_77_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_78: lambda_param_with_default
static asdl_seq *
_loop0_78_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // lambda_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_78[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_with_default"));
        NameDefaultPair* lambda_param_with_default_var;
        while (
            (lambda_param_with_default_var = lambda_param_with_default_rule(p))  // lambda_param_with_default
        )
        {
            _res = lambda_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_78[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_with_default"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_78_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_79: lambda_param_with_default
static asdl_seq *
_loop1_79_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // lambda_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_79[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_with_default"));
        NameDefaultPair* lambda_param_with_default_var;
        while (
            (lambda_param_with_default_var = lambda_param_with_default_rule(p))  // lambda_param_with_default
        )
        {
            _res = lambda_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_79[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_79_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_80: lambda_param_no_default
static asdl_seq *
_loop1_80_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_80[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default"));
        arg_ty lambda_param_no_default_var;
        while (
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            _res = lambda_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_80[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_no_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_80_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_81: lambda_param_no_default
static asdl_seq *
_loop1_81_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_81[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default"));
        arg_ty lambda_param_no_default_var;
        while (
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            _res = lambda_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_81[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_no_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_81_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_82: lambda_param_no_default
static asdl_seq *
_loop0_82_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_82[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default"));
        arg_ty lambda_param_no_default_var;
        while (
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            _res = lambda_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_82[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_no_default"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_82_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_83: lambda_param_with_default
static asdl_seq *
_loop1_83_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // lambda_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_83[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_with_default"));
        NameDefaultPair* lambda_param_with_default_var;
        while (
            (lambda_param_with_default_var = lambda_param_with_default_rule(p))  // lambda_param_with_default
        )
        {
            _res = lambda_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_83[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_83_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_84: lambda_param_no_default
static asdl_seq *
_loop0_84_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_84[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default"));
        arg_ty lambda_param_no_default_var;
        while (
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            _res = lambda_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_84[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_no_default"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_84_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_85: lambda_param_with_default
static asdl_seq *
_loop1_85_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // lambda_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_85[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_with_default"));
        NameDefaultPair* lambda_param_with_default_var;
        while (
            (lambda_param_with_default_var = lambda_param_with_default_rule(p))  // lambda_param_with_default
        )
        {
            _res = lambda_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_85[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_85_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_86: lambda_param_maybe_default
static asdl_seq *
_loop0_86_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // lambda_param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_86[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_maybe_default"));
        NameDefaultPair* lambda_param_maybe_default_var;
        while (
            (lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p))  // lambda_param_maybe_default
        )
        {
            _res = lambda_param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_86[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_maybe_default"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_86_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_87: lambda_param_maybe_default
static asdl_seq *
_loop1_87_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // lambda_param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_87[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_maybe_default"));
        NameDefaultPair* lambda_param_maybe_default_var;
        while (
            (lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p))  // lambda_param_maybe_default
        )
        {
            _res = lambda_param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_87[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_maybe_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_87_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_88: ('or' conjunction)
static asdl_seq *
_loop1_88_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ('or' conjunction)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_88[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "('or' conjunction)"));
        void *_tmp_143_var;
        while (
            (_tmp_143_var = _tmp_143_rule(p))  // 'or' conjunction
        )
        {
            _res = _tmp_143_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_88[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "('or' conjunction)"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_88_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_89: ('and' inversion)
static asdl_seq *
_loop1_89_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ('and' inversion)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_89[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "('and' inversion)"));
        void *_tmp_144_var;
        while (
            (_tmp_144_var = _tmp_144_rule(p))  // 'and' inversion
        )
        {
            _res = _tmp_144_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_89[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "('and' inversion)"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_89_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_90: compare_op_bitwise_or_pair
static asdl_seq *
_loop1_90_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // compare_op_bitwise_or_pair
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_90[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "compare_op_bitwise_or_pair"));
        CmpopExprPair* compare_op_bitwise_or_pair_var;
        while (
            (compare_op_bitwise_or_pair_var = compare_op_bitwise_or_pair_rule(p))  // compare_op_bitwise_or_pair
        )
        {
            _res = compare_op_bitwise_or_pair_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_90[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "compare_op_bitwise_or_pair"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_90_type, _seq);
    p->level--;
    return _seq;
}

// _tmp_91: '!='
static void *
_tmp_91_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '!='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_91[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'!='"));
        Token * tok;
        if (
            (tok = _PyPegen_expect_token(p, 28))  // token='!='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_91[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'!='"));
            _res = _PyPegen_check_barry_as_flufl ( p , tok ) ? NULL : tok;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_91[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'!='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_93: ',' slice
static asdl_seq *
_loop0_93_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' slice
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_93[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' slice"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = slice_rule(p))  // slice
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_93[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' slice"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_93_type, _seq);
    p->level--;
    return _seq;
}

// _gather_92: slice _loop0_93
static asdl_seq *
_gather_92_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // slice _loop0_93
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_92[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "slice _loop0_93"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = slice_rule(p))  // slice
            &&
            (seq = _loop0_93_rule(p))  // _loop0_93
        )
        {
            D(fprintf(stderr, "%*c+ _gather_92[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "slice _loop0_93"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_92[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "slice _loop0_93"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_94: ':' expression?
static void *
_tmp_94_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ':' expression?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_94[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "':' expression?"));
        Token * _literal;
        void *d;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (d = expression_rule(p), !p->error_indicator)  // expression?
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_94[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "':' expression?"));
            _res = d;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_94[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "':' expression?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_95: tuple | group | genexp
static void *
_tmp_95_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // tuple
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_95[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "tuple"));
        expr_ty tuple_var;
        if (
            (tuple_var = tuple_rule(p))  // tuple
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_95[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "tuple"));
            _res = tuple_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_95[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "tuple"));
    }
    { // group
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_95[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "group"));
        expr_ty group_var;
        if (
            (group_var = group_rule(p))  // group
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_95[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "group"));
            _res = group_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_95[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "group"));
    }
    { // genexp
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_95[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "genexp"));
        expr_ty genexp_var;
        if (
            (genexp_var = genexp_rule(p))  // genexp
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_95[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "genexp"));
            _res = genexp_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_95[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "genexp"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_96: list | listcomp
static void *
_tmp_96_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // list
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_96[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "list"));
        expr_ty list_var;
        if (
            (list_var = list_rule(p))  // list
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_96[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "list"));
            _res = list_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_96[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "list"));
    }
    { // listcomp
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_96[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "listcomp"));
        expr_ty listcomp_var;
        if (
            (listcomp_var = listcomp_rule(p))  // listcomp
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_96[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "listcomp"));
            _res = listcomp_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_96[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "listcomp"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_97: dict | set | dictcomp | setcomp
static void *
_tmp_97_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // dict
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_97[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "dict"));
        expr_ty dict_var;
        if (
            (dict_var = dict_rule(p))  // dict
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_97[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "dict"));
            _res = dict_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_97[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "dict"));
    }
    { // set
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_97[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "set"));
        expr_ty set_var;
        if (
            (set_var = set_rule(p))  // set
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_97[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "set"));
            _res = set_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_97[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "set"));
    }
    { // dictcomp
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_97[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "dictcomp"));
        expr_ty dictcomp_var;
        if (
            (dictcomp_var = dictcomp_rule(p))  // dictcomp
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_97[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "dictcomp"));
            _res = dictcomp_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_97[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "dictcomp"));
    }
    { // setcomp
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_97[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "setcomp"));
        expr_ty setcomp_var;
        if (
            (setcomp_var = setcomp_rule(p))  // setcomp
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_97[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "setcomp"));
            _res = setcomp_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_97[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "setcomp"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_98: STRING
static asdl_seq *
_loop1_98_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // STRING
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_98[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "STRING"));
        expr_ty string_var;
        while (
            (string_var = _PyPegen_string_token(p))  // STRING
        )
        {
            _res = string_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_98[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "STRING"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_98_type, _seq);
    p->level--;
    return _seq;
}

// _tmp_99: star_named_expression ',' star_named_expressions?
static void *
_tmp_99_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // star_named_expression ',' star_named_expressions?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_99[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_named_expression ',' star_named_expressions?"));
        Token * _literal;
        expr_ty y;
        void *z;
        if (
            (y = star_named_expression_rule(p))  // star_named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (z = star_named_expressions_rule(p), !p->error_indicator)  // star_named_expressions?
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_99[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_named_expression ',' star_named_expressions?"));
            _res = _PyPegen_seq_insert_in_front ( p , y , z );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_99[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_named_expression ',' star_named_expressions?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_100: yield_expr | named_expression
static void *
_tmp_100_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // yield_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_100[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "yield_expr"));
        expr_ty yield_expr_var;
        if (
            (yield_expr_var = yield_expr_rule(p))  // yield_expr
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_100[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "yield_expr"));
            _res = yield_expr_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_100[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "yield_expr"));
    }
    { // named_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_100[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "named_expression"));
        expr_ty named_expression_var;
        if (
            (named_expression_var = named_expression_rule(p))  // named_expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_100[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "named_expression"));
            _res = named_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_100[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "named_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_102: ',' double_starred_kvpair
static asdl_seq *
_loop0_102_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' double_starred_kvpair
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_102[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' double_starred_kvpair"));
        Token * _literal;
        KeyValuePair* elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = double_starred_kvpair_rule(p))  // double_starred_kvpair
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_102[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' double_starred_kvpair"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_102_type, _seq);
    p->level--;
    return _seq;
}

// _gather_101: double_starred_kvpair _loop0_102
static asdl_seq *
_gather_101_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // double_starred_kvpair _loop0_102
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_101[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "double_starred_kvpair _loop0_102"));
        KeyValuePair* elem;
        asdl_seq * seq;
        if (
            (elem = double_starred_kvpair_rule(p))  // double_starred_kvpair
            &&
            (seq = _loop0_102_rule(p))  // _loop0_102
        )
        {
            D(fprintf(stderr, "%*c+ _gather_101[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "double_starred_kvpair _loop0_102"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_101[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "double_starred_kvpair _loop0_102"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_103: for_if_clause
static asdl_seq *
_loop1_103_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // for_if_clause
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_103[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "for_if_clause"));
        comprehension_ty for_if_clause_var;
        while (
            (for_if_clause_var = for_if_clause_rule(p))  // for_if_clause
        )
        {
            _res = for_if_clause_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_103[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "for_if_clause"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_103_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_104: ('if' disjunction)
static asdl_seq *
_loop0_104_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ('if' disjunction)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_104[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "('if' disjunction)"));
        void *_tmp_145_var;
        while (
            (_tmp_145_var = _tmp_145_rule(p))  // 'if' disjunction
        )
        {
            _res = _tmp_145_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_104[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "('if' disjunction)"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_104_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_105: ('if' disjunction)
static asdl_seq *
_loop0_105_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ('if' disjunction)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_105[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "('if' disjunction)"));
        void *_tmp_146_var;
        while (
            (_tmp_146_var = _tmp_146_rule(p))  // 'if' disjunction
        )
        {
            _res = _tmp_146_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_105[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "('if' disjunction)"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_105_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_107: ',' (starred_expression | named_expression !'=')
static asdl_seq *
_loop0_107_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' (starred_expression | named_expression !'=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_107[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' (starred_expression | named_expression !'=')"));
        Token * _literal;
        void *elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = _tmp_147_rule(p))  // starred_expression | named_expression !'='
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_107[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' (starred_expression | named_expression !'=')"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_107_type, _seq);
    p->level--;
    return _seq;
}

// _gather_106: (starred_expression | named_expression !'=') _loop0_107
static asdl_seq *
_gather_106_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // (starred_expression | named_expression !'=') _loop0_107
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_106[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "(starred_expression | named_expression !'=') _loop0_107"));
        void *elem;
        asdl_seq * seq;
        if (
            (elem = _tmp_147_rule(p))  // starred_expression | named_expression !'='
            &&
            (seq = _loop0_107_rule(p))  // _loop0_107
        )
        {
            D(fprintf(stderr, "%*c+ _gather_106[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "(starred_expression | named_expression !'=') _loop0_107"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_106[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "(starred_expression | named_expression !'=') _loop0_107"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_108: ',' kwargs
static void *
_tmp_108_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ',' kwargs
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_108[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' kwargs"));
        Token * _literal;
        asdl_seq* k;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (k = kwargs_rule(p))  // kwargs
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_108[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "',' kwargs"));
            _res = k;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_108[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' kwargs"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_110: ',' kwarg_or_starred
static asdl_seq *
_loop0_110_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' kwarg_or_starred
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_110[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' kwarg_or_starred"));
        Token * _literal;
        KeywordOrStarred* elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = kwarg_or_starred_rule(p))  // kwarg_or_starred
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_110[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' kwarg_or_starred"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_110_type, _seq);
    p->level--;
    return _seq;
}

// _gather_109: kwarg_or_starred _loop0_110
static asdl_seq *
_gather_109_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // kwarg_or_starred _loop0_110
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_109[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "kwarg_or_starred _loop0_110"));
        KeywordOrStarred* elem;
        asdl_seq * seq;
        if (
            (elem = kwarg_or_starred_rule(p))  // kwarg_or_starred
            &&
            (seq = _loop0_110_rule(p))  // _loop0_110
        )
        {
            D(fprintf(stderr, "%*c+ _gather_109[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "kwarg_or_starred _loop0_110"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_109[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "kwarg_or_starred _loop0_110"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_112: ',' kwarg_or_double_starred
static asdl_seq *
_loop0_112_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' kwarg_or_double_starred
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_112[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' kwarg_or_double_starred"));
        Token * _literal;
        KeywordOrStarred* elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = kwarg_or_double_starred_rule(p))  // kwarg_or_double_starred
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_112[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' kwarg_or_double_starred"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_112_type, _seq);
    p->level--;
    return _seq;
}

// _gather_111: kwarg_or_double_starred _loop0_112
static asdl_seq *
_gather_111_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // kwarg_or_double_starred _loop0_112
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_111[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "kwarg_or_double_starred _loop0_112"));
        KeywordOrStarred* elem;
        asdl_seq * seq;
        if (
            (elem = kwarg_or_double_starred_rule(p))  // kwarg_or_double_starred
            &&
            (seq = _loop0_112_rule(p))  // _loop0_112
        )
        {
            D(fprintf(stderr, "%*c+ _gather_111[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "kwarg_or_double_starred _loop0_112"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_111[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "kwarg_or_double_starred _loop0_112"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_114: ',' kwarg_or_starred
static asdl_seq *
_loop0_114_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' kwarg_or_starred
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_114[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' kwarg_or_starred"));
        Token * _literal;
        KeywordOrStarred* elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = kwarg_or_starred_rule(p))  // kwarg_or_starred
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_114[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' kwarg_or_starred"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_114_type, _seq);
    p->level--;
    return _seq;
}

// _gather_113: kwarg_or_starred _loop0_114
static asdl_seq *
_gather_113_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // kwarg_or_starred _loop0_114
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_113[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "kwarg_or_starred _loop0_114"));
        KeywordOrStarred* elem;
        asdl_seq * seq;
        if (
            (elem = kwarg_or_starred_rule(p))  // kwarg_or_starred
            &&
            (seq = _loop0_114_rule(p))  // _loop0_114
        )
        {
            D(fprintf(stderr, "%*c+ _gather_113[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "kwarg_or_starred _loop0_114"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_113[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "kwarg_or_starred _loop0_114"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_116: ',' kwarg_or_double_starred
static asdl_seq *
_loop0_116_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' kwarg_or_double_starred
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_116[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' kwarg_or_double_starred"));
        Token * _literal;
        KeywordOrStarred* elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = kwarg_or_double_starred_rule(p))  // kwarg_or_double_starred
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_116[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' kwarg_or_double_starred"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_116_type, _seq);
    p->level--;
    return _seq;
}

// _gather_115: kwarg_or_double_starred _loop0_116
static asdl_seq *
_gather_115_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // kwarg_or_double_starred _loop0_116
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_115[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "kwarg_or_double_starred _loop0_116"));
        KeywordOrStarred* elem;
        asdl_seq * seq;
        if (
            (elem = kwarg_or_double_starred_rule(p))  // kwarg_or_double_starred
            &&
            (seq = _loop0_116_rule(p))  // _loop0_116
        )
        {
            D(fprintf(stderr, "%*c+ _gather_115[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "kwarg_or_double_starred _loop0_116"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_115[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "kwarg_or_double_starred _loop0_116"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_117: (',' star_target)
static asdl_seq *
_loop0_117_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // (',' star_target)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_117[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "(',' star_target)"));
        void *_tmp_148_var;
        while (
            (_tmp_148_var = _tmp_148_rule(p))  // ',' star_target
        )
        {
            _res = _tmp_148_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_117[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "(',' star_target)"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_117_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_119: ',' star_target
static asdl_seq *
_loop0_119_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' star_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_119[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' star_target"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = star_target_rule(p))  // star_target
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_119[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' star_target"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_119_type, _seq);
    p->level--;
    return _seq;
}

// _gather_118: star_target _loop0_119
static asdl_seq *
_gather_118_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // star_target _loop0_119
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_118[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_target _loop0_119"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = star_target_rule(p))  // star_target
            &&
            (seq = _loop0_119_rule(p))  // _loop0_119
        )
        {
            D(fprintf(stderr, "%*c+ _gather_118[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_target _loop0_119"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_118[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_target _loop0_119"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_120: (',' star_target)
static asdl_seq *
_loop1_120_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // (',' star_target)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_120[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "(',' star_target)"));
        void *_tmp_149_var;
        while (
            (_tmp_149_var = _tmp_149_rule(p))  // ',' star_target
        )
        {
            _res = _tmp_149_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_120[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "(',' star_target)"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_120_type, _seq);
    p->level--;
    return _seq;
}

// _tmp_121: !'*' star_target
static void *
_tmp_121_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // !'*' star_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_121[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "!'*' star_target"));
        expr_ty star_target_var;
        if (
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 16)  // token='*'
            &&
            (star_target_var = star_target_rule(p))  // star_target
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_121[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "!'*' star_target"));
            _res = star_target_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_121[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "!'*' star_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_123: ',' del_target
static asdl_seq *
_loop0_123_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // ',' del_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_123[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' del_target"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = del_target_rule(p))  // del_target
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_123[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' del_target"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_123_type, _seq);
    p->level--;
    return _seq;
}

// _gather_122: del_target _loop0_123
static asdl_seq *
_gather_122_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // del_target _loop0_123
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_122[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "del_target _loop0_123"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = del_target_rule(p))  // del_target
            &&
            (seq = _loop0_123_rule(p))  // _loop0_123
        )
        {
            D(fprintf(stderr, "%*c+ _gather_122[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "del_target _loop0_123"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_122[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "del_target _loop0_123"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_124: args | expression for_if_clauses
static void *
_tmp_124_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // args
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_124[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "args"));
        expr_ty args_var;
        if (
            (args_var = args_rule(p))  // args
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_124[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "args"));
            _res = args_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_124[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "args"));
    }
    { // expression for_if_clauses
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_124[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "expression for_if_clauses"));
        expr_ty expression_var;
        asdl_seq* for_if_clauses_var;
        if (
            (expression_var = expression_rule(p))  // expression
            &&
            (for_if_clauses_var = for_if_clauses_rule(p))  // for_if_clauses
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_124[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression for_if_clauses"));
            _res = _PyPegen_dummy_name(p, expression_var, for_if_clauses_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_124[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "expression for_if_clauses"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_125: NAME '='
static void *
_tmp_125_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // NAME '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_125[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NAME '='"));
        Token * _literal;
        expr_ty name_var;
        if (
            (name_var = _PyPegen_name_token(p))  // NAME
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_125[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME '='"));
            _res = _PyPegen_dummy_name(p, name_var, _literal);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_125[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NAME '='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_126: star_named_expressions
static asdl_seq *
_loop0_126_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // star_named_expressions
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_126[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_named_expressions"));
        asdl_seq* star_named_expressions_var;
        while (
            (star_named_expressions_var = star_named_expressions_rule(p))  // star_named_expressions
        )
        {
            _res = star_named_expressions_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_126[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_named_expressions"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_126_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_127: (star_targets '=')
static asdl_seq *
_loop0_127_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // (star_targets '=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_127[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "(star_targets '=')"));
        void *_tmp_150_var;
        while (
            (_tmp_150_var = _tmp_150_rule(p))  // star_targets '='
        )
        {
            _res = _tmp_150_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_127[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "(star_targets '=')"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_127_type, _seq);
    p->level--;
    return _seq;
}

// _loop0_128: (star_targets '=')
static asdl_seq *
_loop0_128_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // (star_targets '=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_128[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "(star_targets '=')"));
        void *_tmp_151_var;
        while (
            (_tmp_151_var = _tmp_151_rule(p))  // star_targets '='
        )
        {
            _res = _tmp_151_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_128[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "(star_targets '=')"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_128_type, _seq);
    p->level--;
    return _seq;
}

// _tmp_129: yield_expr | star_expressions
static void *
_tmp_129_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // yield_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_129[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "yield_expr"));
        expr_ty yield_expr_var;
        if (
            (yield_expr_var = yield_expr_rule(p))  // yield_expr
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_129[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "yield_expr"));
            _res = yield_expr_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_129[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "yield_expr"));
    }
    { // star_expressions
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_129[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_expressions"));
        expr_ty star_expressions_var;
        if (
            (star_expressions_var = star_expressions_rule(p))  // star_expressions
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_129[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_expressions"));
            _res = star_expressions_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_129[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_expressions"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_130: '[' | '(' | '{'
static void *
_tmp_130_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '['
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_130[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'['"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_130[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'['"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_130[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'['"));
    }
    { // '('
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_130[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'('"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_130[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'('"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_130[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'('"));
    }
    { // '{'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_130[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'{'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_130[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'{'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_130[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'{'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_131: param_no_default
static asdl_seq *
_loop0_131_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_131[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_no_default"));
        arg_ty param_no_default_var;
        while (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            _res = param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_131[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_no_default"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_131_type, _seq);
    p->level--;
    return _seq;
}

// _tmp_132: slash_with_default | param_with_default+
static void *
_tmp_132_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // slash_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_132[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "slash_with_default"));
        SlashWithDefault* slash_with_default_var;
        if (
            (slash_with_default_var = slash_with_default_rule(p))  // slash_with_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_132[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "slash_with_default"));
            _res = slash_with_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_132[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "slash_with_default"));
    }
    { // param_with_default+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_132[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_with_default+"));
        asdl_seq * _loop1_152_var;
        if (
            (_loop1_152_var = _loop1_152_rule(p))  // param_with_default+
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_132[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "param_with_default+"));
            _res = _loop1_152_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_132[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_with_default+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_133: lambda_param_no_default
static asdl_seq *
_loop0_133_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_133[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_no_default"));
        arg_ty lambda_param_no_default_var;
        while (
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            _res = lambda_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_133[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_no_default"));
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop0_133_type, _seq);
    p->level--;
    return _seq;
}

// _tmp_134: lambda_slash_with_default | lambda_param_with_default+
static void *
_tmp_134_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // lambda_slash_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_134[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_slash_with_default"));
        SlashWithDefault* lambda_slash_with_default_var;
        if (
            (lambda_slash_with_default_var = lambda_slash_with_default_rule(p))  // lambda_slash_with_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_134[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_slash_with_default"));
            _res = lambda_slash_with_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_134[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_slash_with_default"));
    }
    { // lambda_param_with_default+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_134[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_with_default+"));
        asdl_seq * _loop1_153_var;
        if (
            (_loop1_153_var = _loop1_153_rule(p))  // lambda_param_with_default+
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_134[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "lambda_param_with_default+"));
            _res = _loop1_153_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_134[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_with_default+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_135: ')' | ',' (')' | '**')
static void *
_tmp_135_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_135[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "')'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_135[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "')'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_135[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "')'"));
    }
    { // ',' (')' | '**')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_135[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' (')' | '**')"));
        Token * _literal;
        void *_tmp_154_var;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_tmp_154_var = _tmp_154_rule(p))  // ')' | '**'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_135[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "',' (')' | '**')"));
            _res = _PyPegen_dummy_name(p, _literal, _tmp_154_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_135[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' (')' | '**')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_136: ':' | ',' (':' | '**')
static void *
_tmp_136_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_136[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "':'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_136[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "':'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_136[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "':'"));
    }
    { // ',' (':' | '**')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_136[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' (':' | '**')"));
        Token * _literal;
        void *_tmp_155_var;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_tmp_155_var = _tmp_155_rule(p))  // ':' | '**'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_136[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "',' (':' | '**')"));
            _res = _PyPegen_dummy_name(p, _literal, _tmp_155_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_136[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' (':' | '**')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_137: star_targets '='
static void *
_tmp_137_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // star_targets '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_137[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_targets '='"));
        Token * _literal;
        expr_ty z;
        if (
            (z = star_targets_rule(p))  // star_targets
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_137[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_targets '='"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_137[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_targets '='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_138: '.' | '...'
static void *
_tmp_138_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '.'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_138[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'.'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_138[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'.'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_138[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'.'"));
    }
    { // '...'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_138[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'...'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 52))  // token='...'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_138[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'...'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_138[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'...'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_139: '.' | '...'
static void *
_tmp_139_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '.'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_139[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'.'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_139[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'.'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_139[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'.'"));
    }
    { // '...'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_139[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'...'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 52))  // token='...'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_139[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'...'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_139[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'...'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_140: '@' named_expression NEWLINE
static void *
_tmp_140_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '@' named_expression NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_140[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'@' named_expression NEWLINE"));
        Token * _literal;
        expr_ty f;
        Token * newline_var;
        if (
            (_literal = _PyPegen_expect_token(p, 49))  // token='@'
            &&
            (f = named_expression_rule(p))  // named_expression
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_140[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'@' named_expression NEWLINE"));
            _res = f;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_140[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'@' named_expression NEWLINE"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_141: ',' star_expression
static void *
_tmp_141_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ',' star_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_141[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' star_expression"));
        Token * _literal;
        expr_ty c;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (c = star_expression_rule(p))  // star_expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_141[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "',' star_expression"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_141[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' star_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_142: ',' expression
static void *
_tmp_142_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ',' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_142[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' expression"));
        Token * _literal;
        expr_ty c;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (c = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_142[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "',' expression"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_142[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_143: 'or' conjunction
static void *
_tmp_143_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'or' conjunction
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_143[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'or' conjunction"));
        Token * _keyword;
        expr_ty c;
        if (
            (_keyword = _PyPegen_expect_token(p, 532))  // token='or'
            &&
            (c = conjunction_rule(p))  // conjunction
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_143[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'or' conjunction"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_143[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'or' conjunction"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_144: 'and' inversion
static void *
_tmp_144_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'and' inversion
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_144[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'and' inversion"));
        Token * _keyword;
        expr_ty c;
        if (
            (_keyword = _PyPegen_expect_token(p, 533))  // token='and'
            &&
            (c = inversion_rule(p))  // inversion
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_144[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'and' inversion"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_144[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'and' inversion"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_145: 'if' disjunction
static void *
_tmp_145_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'if' disjunction
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_145[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'if' disjunction"));
        Token * _keyword;
        expr_ty z;
        if (
            (_keyword = _PyPegen_expect_token(p, 510))  // token='if'
            &&
            (z = disjunction_rule(p))  // disjunction
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_145[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'if' disjunction"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_145[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'if' disjunction"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_146: 'if' disjunction
static void *
_tmp_146_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'if' disjunction
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_146[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'if' disjunction"));
        Token * _keyword;
        expr_ty z;
        if (
            (_keyword = _PyPegen_expect_token(p, 510))  // token='if'
            &&
            (z = disjunction_rule(p))  // disjunction
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_146[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'if' disjunction"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_146[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'if' disjunction"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_147: starred_expression | named_expression !'='
static void *
_tmp_147_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // starred_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_147[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "starred_expression"));
        expr_ty starred_expression_var;
        if (
            (starred_expression_var = starred_expression_rule(p))  // starred_expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_147[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "starred_expression"));
            _res = starred_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_147[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "starred_expression"));
    }
    { // named_expression !'='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_147[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "named_expression !'='"));
        expr_ty named_expression_var;
        if (
            (named_expression_var = named_expression_rule(p))  // named_expression
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 22)  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_147[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "named_expression !'='"));
            _res = named_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_147[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "named_expression !'='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_148: ',' star_target
static void *
_tmp_148_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ',' star_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_148[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' star_target"));
        Token * _literal;
        expr_ty c;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (c = star_target_rule(p))  // star_target
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_148[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "',' star_target"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_148[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' star_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_149: ',' star_target
static void *
_tmp_149_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ',' star_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_149[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "',' star_target"));
        Token * _literal;
        expr_ty c;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (c = star_target_rule(p))  // star_target
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_149[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "',' star_target"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_149[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "',' star_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_150: star_targets '='
static void *
_tmp_150_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // star_targets '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_150[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_targets '='"));
        Token * _literal;
        expr_ty star_targets_var;
        if (
            (star_targets_var = star_targets_rule(p))  // star_targets
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_150[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_targets '='"));
            _res = _PyPegen_dummy_name(p, star_targets_var, _literal);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_150[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_targets '='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_151: star_targets '='
static void *
_tmp_151_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // star_targets '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_151[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "star_targets '='"));
        Token * _literal;
        expr_ty star_targets_var;
        if (
            (star_targets_var = star_targets_rule(p))  // star_targets
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_151[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_targets '='"));
            _res = _PyPegen_dummy_name(p, star_targets_var, _literal);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_151[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "star_targets '='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_152: param_with_default
static asdl_seq *
_loop1_152_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_152[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "param_with_default"));
        NameDefaultPair* param_with_default_var;
        while (
            (param_with_default_var = param_with_default_rule(p))  // param_with_default
        )
        {
            _res = param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_152[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_152_type, _seq);
    p->level--;
    return _seq;
}

// _loop1_153: lambda_param_with_default
static asdl_seq *
_loop1_153_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    int _start_mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    ssize_t _children_capacity = 1;
    ssize_t _n = 0;
    { // lambda_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_153[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "lambda_param_with_default"));
        NameDefaultPair* lambda_param_with_default_var;
        while (
            (lambda_param_with_default_var = lambda_param_with_default_rule(p))  // lambda_param_with_default
        )
        {
            _res = lambda_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_153[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "lambda_param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
    PyMem_Free(_children);
    _PyPegen_insert_memo(p, _start_mark, _loop1_153_type, _seq);
    p->level--;
    return _seq;
}

// _tmp_154: ')' | '**'
static void *
_tmp_154_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_154[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "')'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_154[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "')'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_154[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "')'"));
    }
    { // '**'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_154[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'**'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_154[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'**'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_154[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'**'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_155: ':' | '**'
static void *
_tmp_155_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_155[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "':'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_155[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "':'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_155[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "':'"));
    }
    { // '**'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_155[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'**'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_155[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'**'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_155[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'**'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

void *
_PyPegen_parse(Parser *p)
{
    // Initialize keywords
    p->keywords = reserved_keywords;
    p->n_keyword_lists = n_keyword_lists;

    // Run parser
    void *result = NULL;
    if (p->start_rule == Py_file_input) {
        result = file_rule(p);
    } else if (p->start_rule == Py_single_input) {
        result = interactive_rule(p);
    } else if (p->start_rule == Py_eval_input) {
        result = eval_rule(p);
    } else if (p->start_rule == Py_func_type_input) {
        result = func_type_rule(p);
    } else if (p->start_rule == Py_fstring_input) {
        result = fstring_rule(p);
    }

    return result;
}

// The end
